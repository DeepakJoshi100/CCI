<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EduManage - Institute Management</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
   <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>

<body>

    <!-- üéØ GLOBAL APP LOADER -->
    <div id="globalAppLoader" style="
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 99999;
        transition: opacity 0.3s ease;
    ">
        <div style="
            width: 60px; height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        "></div>
        <div style="
            margin-top: 20px;
            font-size: 1.1rem;
            color: #495057;
            font-weight: 500;
        ">Loading EduManage...</div>
        <div style="
            margin-top: 8px;
            font-size: 0.9rem;
            color: #6c757d;
        ">Please wait while we set things up for you.</div>
    </div>

    <style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    </style>
    <script>
        // üëá FALLBACK: Hide loader after 5 seconds max (in case something breaks)
        setTimeout(() => {
            const loader = document.getElementById('globalAppLoader');
            if (loader && loader.style.display !== 'none') {
                loader.style.opacity = '0';
                setTimeout(() => { if (loader) loader.style.display = 'none'; }, 300);
            }
        }, 5000);
    </script>
    <div class="container">
        <aside class="sidebar">
            <div class="logo">
                <h2><i class="fas fa-graduation-cap"></i> EduManage</h2>
            </div>
            <nav class="navigation">
                <ul>
                    <li><a href="#dashboard" class="nav-link"><i class="fas fa-tachometer-alt"></i> Dashboard</a></li>
                    <li><a href="#students" class="nav-link"><i class="fas fa-users"></i> Students</a></li>
                    <li><a href="#batches" class="nav-link"><i class="fas fa-layer-group"></i> Batches</a></li>
                    <li><a href="#fees" class="nav-link"><i class="fas fa-money-bill-wave"></i> Fees</a></li>
                </ul>
                <div style="flex: 1;"></div>
                <ul style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <li><a href="#all-students" class="nav-link"> <i class="fas fa-archive"></i> All Students </a></li>
                </ul>
            </nav>
            <div class="sidebar-footer">
                <p>¬© 2023 EduManage</p>
            </div>
        </aside>
        <!-- Main Content -->
        <main class="main-content">
            <header class="header">
                <div class="header-left">
                    <button class="menu-toggle" id="menuToggle">
                        <i class="fas fa-bars"></i>
                    </button>
                    <h1 id="page-title">Dashboard</h1>
                </div>
                <div class="header-right">
                    <div class="user-profile"> <i class="fas fa-user-circle"></i> <span
                            id="user-email">Loading...</span> <button onclick="Auth.logout()" class="btn btn-link"
                            style="color: #fff; margin-left: 10px;"> <i class="fas fa-sign-out-alt"></i> Logout
                        </button> </div>
                </div>
            </header>

            <div class="content">
                <!-- DASHBOARD SECTION -->
                <section id="dashboard-section" class="section">
                    <div class="dashboard-container">
                        <div class="loading-overlay" id="dashboard-loading">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Loading dashboard data...</div>
                        </div>
                        <div class="stats-cards">
                            <div class="stat-card">
                                <div class="stat-icon bg-primary">
                                    <i class="fas fa-users"></i>
                                </div>
                                <div class="stat-info">
                                    <h3 id="total-students">0</h3>
                                    <p>Total Students</p>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon bg-success">
                                    <i class="fas fa-layer-group"></i>
                                </div>
                                <div class="stat-info">
                                    <h3 id="total-batches">0</h3>
                                    <p>Total Batches</p>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon bg-warning">
                                    <i class="fas fa-money-bill-wave"></i>
                                </div>
                                <div class="stat-info">
                                    <h3 id="total-revenue">‚Çπ0</h3>
                                    <p>Total Revenue</p>
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon bg-danger">
                                    <i class="fas fa-exclamation-triangle"></i>
                                </div>
                                <div class="stat-info">
                                    <h3 id="pending-fees">‚Çπ0</h3>
                                    <p>Pending Fees</p>
                                </div>
                            </div>
                        </div>

                        <div class="charts-container">
                            <div class="chart-box">
                                <h3>Students by Batch</h3>
                                <canvas id="batchDistributionChart" height="300"></canvas>
                            </div>
                            <div class="chart-box">
                                <h3>Monthly Fee Collection</h3>
                                <canvas id="feeCollectionChart" height="300"></canvas>
                            </div>
                        </div>

                        <div class="recent-activity">
                            <h3>Recent Activity</h3>
                            <div class="activity-list" id="activity-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- STUDENTS SECTION -->
                <section id="students-section" class="section">
                    <div class="page-header">
                        <h2>All Students</h2>
                        <button class="btn btn-primary" id="addStudentBtn">
                            <i class="fas fa-plus"></i> Add Student
                        </button>
                    </div>
                    <div class="section-content-wrapper" style="position: relative;">
                        <div class="loading-overlay" id="students-loading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Loading students...</div>
                        </div>
                        <div class="filters">
                            <div class="search-box">
                                <input type="text" id="searchStudent" placeholder="Search by name or father's name...">
                                <i class="fas fa-search"></i>
                            </div>
                            <div class="filter-options">
                                <select id="filterByBatch">
                                    <option value="">All Batches</option>
                                </select>
                                <select id="filterByCourse">
                                    <option value="">All Courses</option>
                                </select>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Name</th>
                                        <th>Father's Name</th>
                                        <th>Course</th>
                                        <th>Batch</th>
                                        <th>Monthly Fee</th>
                                        <th>Admission Date</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="studentsTableBody">
                                    <tr>
                                        <td colspan="8" class="no-data">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                </section>

                <!-- BATCHES SECTION -->
                <section id="batches-section" class="section">
                    <div class="page-header">
                        <h2>Batch Management</h2>
                        <button class="btn btn-primary" id="addBatchBtn">
                            <i class="fas fa-plus"></i> Add Batch
                        </button>
                    </div>
                    <div class="section-content-wrapper" style="position: relative;">
                        <div class="loading-overlay" id="batches-loading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Loading batches...</div>
                        </div>
                        <div class="batch-selector">
                            <div
                                style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
                                <select id="batchSelector">
                                    <option value="">Loading batches...</option>
                                </select>
                                <button class="btn btn-danger" id="deleteBatchBtn">
                                    <i class="fas fa-trash"></i> Delete Batch
                                </button>
                            </div>
                        </div>
                        <div class="batch-details">
                            <div class="batch-info">
                                <h3 id="batchName">-</h3>
                                <div class="batch-stats">
                                    <div class="stat">
                                        <span class="label">Total Students:</span>
                                        <span class="value" id="batchStudentCount">0</span>
                                    </div>
                                    <div class="stat">
                                        <span class="label">Courses:</span>
                                        <span class="value" id="batchCourses">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="students-in-batch">
                            <h3>Students in this Batch</h3>
                            <div class="table-responsive">
                                <table class="data-table">
                                    <thead>
                                        <tr>
                                            <th>#</th>
                                            <th>Name</th>
                                            <th>Course</th>
                                            <th>Monthly Fee</th>
                                            <th>Admission Date</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="batchStudentsTable">
                                        <tr>
                                            <td colspan="6" class="no-data">Select a batch to view students.</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                </section>

                <!-- FEES SECTION -->
                <section id="fees-section" class="section">
                    <div id="feeSyncStatus"
                        style="display:none; padding:10px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:6px; margin-bottom:20px;">
                        <i class="fas fa-sync fa-spin"></i> Syncing fee records... Please wait.
                    </div>
                    <div class="page-header">
    <h2>Fee Management</h2>
    <div style="display: flex; gap: 10px;">
        <button class="btn btn-primary" id="payFeeBtn">
            <i class="fas fa-money-bill"></i> Record Payment
        </button>
        <button class="btn btn-success" id="downloadExcelBtn">
            <i class="fas fa-file-excel"></i> Download All Data (Excel)
        </button>
    </div>
</div>
                    <div class="section-content-wrapper" style="position: relative;">
                        <div class="loading-overlay" id="fees-loading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Loading fee records...</div>
                        </div>
                        <div class="fee-filters">
                            <div class="search-box">
                                <input type="text" id="feeSearch" placeholder="Search by student name or ID...">
                                <i class="fas fa-search"></i>
                            </div>
                            <div class="filter-options">
                                <select id="feeStatusFilter">
                                    <option value="">All Status</option>
                                    <option value="paid">Paid</option>
                                    <option value="unpaid">Unpaid</option>
                                    <option value="partial">Partial Payment</option>
                                </select>
                                <select id="monthFilter">
                                    <option value="">All Months</option>
                                    <option value="0">January</option>
                                    <option value="1">February</option>
                                    <option value="2">March</option>
                                    <option value="3">April</option>
                                    <option value="4">May</option>
                                    <option value="5">June</option>
                                    <option value="6">July</option>
                                    <option value="7">August</option>
                                    <option value="8">September</option>
                                    <option value="9">October</option>
                                    <option value="10">November</option>
                                    <option value="11">December</option>
                                </select>
                                <select id="yearFilter">
                                    <option value="">All Years</option>
                                </select>
                            </div>
                        </div>
                        <div class="fee-summary">
                            <div class="summary-card">
                                <h4>Total Amount</h4>
                                <p id="totalAmount">‚Çπ0</p>
                            </div>
                            <div class="summary-card">
                                <h4>Paid Amount</h4>
                                <p id="paidAmount">‚Çπ0</p>
                            </div>
                            <div class="summary-card">
                                <h4>Outstanding</h4>
                                <p id="outstandingAmount">‚Çπ0</p>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Student ID</th>
                                        <th>Student Name</th>
                                        <th>Batch</th>
                                        <th>Month/Year</th>
                                        <th>Amount Due</th>
                                        <th>Amount Paid</th>
                                        <th>Status</th>
                                        <th>Payment Date</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="feesTableBody">
                                    <tr>
                                        <td colspan="9" class="no-data">Loading fee records...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                </section>

                <!-- ALL STUDENTS SECTION -->
                <section id="all-students-section" class="section">
                    <div class="page-header">
                        <h2>Complete Student Records</h2>
                        <div style="font-size: 0.9rem; color: #6c757d; font-weight: 500;">
                            <i class="fas fa-info-circle"></i> Read-only archive including deleted students
                        </div>
                    </div>
                    <div class="section-content-wrapper" style="position: relative;">
                        <div class="loading-overlay" id="all-students-loading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Loading all student records...</div>
                        </div>
                        <div class="filters">
                            <div class="search-box">
                                <input type="text" id="searchAllStudents"
                                    placeholder="Search by name or father's name...">
                                <i class="fas fa-search"></i>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Name</th>
                                        <th>Father's Name</th>
                                        <th>Phone</th> <!-- üëà NEW -->
                                        <th>Course</th>
                                        <th>Batch</th>
                                        <th>Admission Date</th>
                                        <th>Total Due</th>
                                        <th>Total Paid</th>
                                        <th>Outstanding</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="allStudentsTableBody">
                                    <tr>
                                        <td colspan="10" class="no-data">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div
                            style="margin-top: 30px; padding: 20px; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <h4><i class="fas fa-lightbulb"></i> About This Page</h4>
                            <p>This archive shows all students ever registered, including those archived ("deleted").
                            </p>
                            <p>Financial summary is calculated from all fee records associated with each student.</p>
                            <p>Active students can be managed from the "Active Students" page.</p>
                        </div>
                </section>
            </div>
        </main>
    </div>

    <!-- MODALS -->

    <!-- Add/Edit Student Modal -->
    <div class="modal" id="addStudentModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="studentModalTitle">Add New Student</h3>
                <button class="close-btn" id="closeStudentModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="studentForm">
                    <input type="hidden" id="studentId" name="studentId">
                    <div class="form-group">
                        <label for="studentName">Full Name *</label>
                        <input type="text" id="studentName" name="studentName" placeholder="Enter full name" required>
                    </div>
                    <div class="form-group">
                        <label for="fatherName">Father's Name *</label>
                        <input type="text" id="fatherName" name="fatherName" placeholder="Enter father's name" required>
                    </div>
                    <div class="form-group">
                        <label for="phone">Phone Numbers (Optional)</label>
                        <textarea id="phone" name="phone" rows="2" placeholder="e.g., 9876543210, 8765432109"
                            style="resize: vertical;"></textarea>
                        <small style="color: #6c757d;">
                            Enter multiple 10-digit numbers separated by commas. Example: 9876543210, 8765432109
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="admissionDate">Admission Date *</label>
                        <input type="date" id="admissionDate" name="admissionDate" required>
                    </div>
                    <div class="form-group">
                        <label for="course">Course *</label>
                        <input type="text" id="course" name="course" placeholder="e.g., Web Development" required>
                    </div>
                    <div class="form-group">
                        <label for="batch">Batch *</label>
                        <select id="batch" name="batch" required>
                            <option value="">Select Batch</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="monthlyFee">Monthly Fee (‚Çπ) *</label>
                        <input type="number" id="monthlyFee" name="monthlyFee" min="0" step="100"
                            placeholder="e.g., 2500" required>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Save Student</button>
                        <button type="button" class="btn btn-secondary" id="cancelStudentBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- Add/Edit Batch Modal -->
    <div class="modal" id="addBatchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="batchModalTitle">Add New Batch</h3>
                <button class="close-btn" id="closeBatchModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="batchForm">
                    <input type="hidden" id="batchId" name="batchId">
                    <div class="form-group">
                        <label for="batchNameInput">Batch Name *</label>
                        <input type="text" id="batchNameInput" name="batchName" placeholder="e.g., Morning Batch 2024"
                            required>
                    </div>
                    <div class="form-group">
                        <label for="batchTiming">Timing (Optional)</label>
                        <input type="text" id="batchTiming" name="timing" placeholder="e.g., 9:00 AM - 11:00 AM">
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Save Batch</button>
                        <button type="button" class="btn btn-secondary" id="cancelBatchBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- Update Student Batch Modal -->
    <div class="modal" id="updateStudentBatchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Update Student Batch</h3>
                <button class="close-btn" id="closeUpdateBatchModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="updateStudentBatchForm">
                    <input type="hidden" id="updateStudentId" name="updateStudentId">
                    <div class="form-group">
                        <label for="newBatch">New Batch *</label>
                        <select id="newBatch" name="newBatch" required>
                            <option value="">Select Batch</option>
                        </select>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Update</button>
                        <button type="button" class="btn btn-secondary" id="cancelUpdateBatchBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- Pay Fee Modal -->
    <div class="modal" id="payFeeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Record Payment</h3>
                <button class="close-btn" id="closePayFeeModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="payFeeForm">
                    <div class="form-group">
                        <label for="studentSelect">Select Student *</label>
                        <select id="studentSelect" name="studentSelect" required>
                            <option value="">Select Student</option>
                        </select>
                        <small style="color: #6c757d;">Total due will auto-calculate based on all unpaid months.</small>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
    <label>
        <input type="checkbox" id="holdPaymentCheckbox">
        Hold this month‚Äôs payment (e.g., student on leave)
    </label>
    <!-- HOLD MONTH SELECTORS (initially hidden/disabled) -->
<div id="holdMonthSelectors" style="display: none; margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
    <h4 style="margin: 0 0 10px 0; font-size: 0.95rem; color: #dc3545;">
        <i class="fas fa-pause-circle"></i> Select Month to Hold
    </h4>
    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 120px;">
            <label>Month</label>
            <select id="holdMonthSelect" class="form-control" disabled>
                <option value="">Select Month</option>
                <option value="0">January</option>
                <option value="1">February</option>
                <option value="2">March</option>
                <option value="3">April</option>
                <option value="4">May</option>
                <option value="5">June</option>
                <option value="6">July</option>
                <option value="7">August</option>
                <option value="8">September</option>
                <option value="9">October</option>
                <option value="10">November</option>
                <option value="11">December</option>
            </select>
        </div>
        <div style="flex: 1; min-width: 120px;">
            <label>Year</label>
            <select id="holdYearSelect" class="form-control" disabled>
                <option value="">Select Year</option>
                <!-- Will be populated by JS -->
            </select>
        </div>
    </div>
    <small style="color: #6c757d; display: block; margin-top: 8px;">
        Selected month will be placed on hold ‚Äî no fee due. Can be un-held later.
    </small>
</div>
    <small style="color: #dc3545; display: block; margin-top: 4px;">
        ‚ö†Ô∏è Selected month will be skipped ‚Äî no fee due. Can be un-held later.
    </small>
</div>
                    <div class="form-group">
                        <label for="amountDue">Total Amount Due *</label>
                        <input type="number" id="amountDue" readonly placeholder="Select student to see due amount">
                    </div>
                    <!-- PAYMENT FIELDS GROUP -->
<div id="paymentFields">
    <div class="form-group">
        <label for="amountPaid">Amount Paid *</label>
        <input type="number" id="amountPaid" min="0" step="10" required placeholder="Enter amount received">
        <small style="color: #6c757d;">Payments are applied to oldest unpaid months first.</small>
    </div>
    <div class="form-group">
        <label for="paymentMethod">Payment Method</label>
        <select id="paymentMethod" name="paymentMethod">
            <option value="cash">Cash</option>
            <option value="bank_transfer">Bank Transfer</option>
            <option value="upi">UPI</option>
            <option value="card">Card</option>
        </select>
    </div>
    <div class="form-group">
        <label for="paymentNotes">Notes (Optional)</label>
        <textarea id="paymentNotes" rows="3" placeholder="Transaction ID, reference, etc."></textarea>
    </div>
</div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">Record Payment</button>
                        <button type="button" class="btn btn-secondary" id="cancelPayFeeBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div> <!-- View Payment Details Modal -->
    <div class="modal" id="viewPaymentModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Payment Details</h3>
                <button class="close-btn" id="closeViewPaymentModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="payment-details" id="paymentDetailsContent">
                    <!-- Populated by JS -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="closeViewPaymentBtn">Close</button>
            </div>
        </div>
    </div>
    <!-- Confirm Password Modal -->
    <div class="modal" id="confirmPasswordModal" style="display:none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Confirm Deletion</h3>
                <button class="close-btn" id="closePasswordModal">&times;</button>
            </div>
            <div class="modal-body">
                <p>‚ö†Ô∏è This will permanently delete the student record. Enter your password to confirm:</p>
                <form id="passwordForm">
                    <div class="form-group">
                        <label for="confirmPassword">Password</label>
                        <input type="password" id="confirmPassword" name="confirmPassword"
                            placeholder="Enter your password" required>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn btn-danger">Delete Permanently</button>
                        <button type="button" class="btn btn-secondary" id="cancelPasswordBtn">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <script type="module">
        // ============================= 
        // üî• FIREBASE CONFIGURATION 
        // ============================= 
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, addDoc, updateDoc, doc, deleteDoc, query, where, writeBatch } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import {
            getAuth,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            GoogleAuthProvider,
            signInWithPopup,
            EmailAuthProvider,           // ‚Üê ADD THIS
            reauthenticateWithCredential // ‚Üê ADD THIS
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        const firebaseConfig = {
            apiKey: "AIzaSyCJhbTQ5ZwLhakUQBGpclZVsZG0V8-qWhs",
            authDomain: "stylestock.firebaseapp.com",
            projectId: "stylestock",
            storageBucket: "stylestock.firebasestorage.app",
            messagingSenderId: "508467185521",
            appId: "1:508467185521:web:71d911a1aff8987cc358d0"
        };
        let CURRENT_USER_ID = null;
        function isMobile() {
            return window.innerWidth <= 768;
        }
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // ============================= 
        // üß† UTILITIES 
        // ============================= 
        function generateId() { return '_' + Math.random().toString(36).substr(2, 9); }
        function formatDate(isoDateString) {
            if (!isoDateString) return '';
            const date = new Date(isoDateString);
            if (isNaN(date.getTime())) return '';
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        }

        // üëáüëáüëá ADD IT RIGHT HERE üëáüëáüëá
        // Loading Screen Helpers
        function showLoading(sectionId) {
            const loadingEl = document.getElementById(`${sectionId}-loading`);
            if (loadingEl) {
                loadingEl.style.display = 'flex';
            }
        }

        function hideLoading(sectionId) {
            const loadingEl = document.getElementById(`${sectionId}-loading`);
            if (loadingEl) {
                loadingEl.style.display = 'none';
            }
        }
        function showToast(message, type = 'success') {
            document.querySelectorAll('.toast').forEach(el => el.remove());
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.style.cssText = ` position: fixed; top: 20px; right: 20px; background: ${type === 'error' ? '#f8d7da' : '#d1e7dd'}; color: ${type === 'error' ? '#721c24' : '#0f5132'}; border: 1px solid ${type === 'error' ? '#f5c6cb' : '#badbcc'}; padding: 12px 20px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10000; font-weight: 500; display: flex; align-items: center; gap: 8px; animation: slideInRight 0.3s ease forwards; `;
            toast.innerHTML = `<i class="fas ${type === 'error' ? 'fa-exclamation-circle' : 'fa-check-circle'}"></i> <span>${message}</span>`;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease forwards';
                setTimeout(() => { if (toast.parentNode) toast.remove(); }, 300);
            }, 3000);
        }
        const style = document.createElement('style');
        style.textContent = ` @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } } `;
        document.head.appendChild(style);

        // ============================= 
        // üíæ FIREBASE STORAGE LAYER (Replaces firebase-utils.js) 
        // ============================= 
        class FirebaseStorage {
            static async getStudents() {
                const q = query(collection(db, "students"), where("ownerId", "==", CURRENT_USER_ID));
                const snapshot = await getDocs(q);
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } static async saveStudent(student) {
                student.ownerId = CURRENT_USER_ID; // üëà ATTACH OWNER ID
                if (student.id) {
                    await updateDoc(doc(db, "students", student.id), student);
                } else {
                    const docRef = await addDoc(collection(db, "students"), student);
                    student.id = docRef.id;
                }
                return student;
            }
            static async archiveStudent(id) { await updateDoc(doc(db, "students", id), { deleted: true }); }
            static async getBatches() {
                const q = query(
                    collection(db, "batches"),
                    where("ownerId", "==", CURRENT_USER_ID)
                );
                const snapshot = await getDocs(q);
                return snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a, b) => (a.name || '').localeCompare(b.name || '')); // ‚Üê SORT BY NAME
            }
            static async saveBatch(batch) {
                batch.ownerId = CURRENT_USER_ID; // üëà ATTACH OWNER ID
                if (batch.id) {
                    await updateDoc(doc(db, "batches", batch.id), batch);
                } else {
                    const docRef = await addDoc(collection(db, "batches"), batch);
                    batch.id = docRef.id;
                }
                return batch;
            } static async deleteBatch(id) { await deleteDoc(doc(db, "batches", id)); }
            static async getFees() {
                const q = query(collection(db, "fees"), where("ownerId", "==", CURRENT_USER_ID));
                const snapshot = await getDocs(q);
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } static async saveFee(fee) {
                fee.ownerId = CURRENT_USER_ID; // üëà ATTACH OWNER ID
                if (fee.id && fee.id.startsWith('_')) delete fee.id;
                if (fee.id) {
                    await updateDoc(doc(db, "fees", fee.id), fee);
                } else {
                    const docRef = await addDoc(collection(db, "fees"), fee);
                    fee.id = docRef.id;
                }
                return fee;
            }
        }
        // ============================= 
        // üóÉÔ∏è DATA CACHE (Session Only) 
        // ============================= 
        class DataCache {
            static _cache = { batches: null, students: null, fees: null };
            static _fetching = { batches: false, students: false, fees: false };
            static async getBatches() { if (this._cache.batches) return this._cache.batches; if (this._fetching.batches) { await new Promise(r => { const i = setInterval(() => { if (!this._fetching.batches) { clearInterval(i); r(); } }, 50); }); return this._cache.batches; } this._fetching.batches = true; try { return this._cache.batches = await FirebaseStorage.getBatches(); } finally { this._fetching.batches = false; } }
            static async getStudents() { if (this._cache.students) return this._cache.students; if (this._fetching.students) { await new Promise(r => { const i = setInterval(() => { if (!this._fetching.students) { clearInterval(i); r(); } }, 50); }); return this._cache.students; } this._fetching.students = true; try { return this._cache.students = await FirebaseStorage.getStudents(); } finally { this._fetching.students = false; } }
            static async getFees() { if (this._cache.fees) return this._cache.fees; if (this._fetching.fees) { await new Promise(r => { const i = setInterval(() => { if (!this._fetching.fees) { clearInterval(i); r(); } }, 50); }); return this._cache.fees; } this._fetching.fees = true; try { return this._cache.fees = await FirebaseStorage.getFees(); } finally { this._fetching.fees = false; } }
            static invalidate(key) { if (key) this._cache[key] = null; else this._cache = { batches: null, students: null, fees: null }; }
        }

        // ============================= 
        // üîê AUTH MODULE 
        // ============================= 
        class Auth {
            static async login(email, password) {
                try {
                    const userCredential = await signInWithEmailAndPassword(auth, email, password);
                    console.log("‚úÖ User logged in:", userCredential.user.email);
                    return userCredential.user;
                } catch (error) {
                    console.error("üîê Login failed:", error.message);
                    showToast(`Login failed: ${error.message}`, 'error');
                    return null;
                }
            }
            static async loginWithGoogle() {
                const provider = new GoogleAuthProvider();
                try {
                    const result = await signInWithPopup(auth, provider);
                    console.log("‚úÖ Google login successful:", result.user.email);
                    return result.user;
                } catch (error) {
                    console.error("üîê Google login failed:", error.message);
                    showToast('Google login failed: ' + error.message, 'error');
                    return null;
                }
            }
            static async logout() {
                try {
                    await signOut(auth);
                    CURRENT_USER_ID = null;           // Reset user ID
                    DataCache.invalidate();           // Clear cache
                    console.log("üö™ User logged out");
                    window.location.href = 'login.html';
                } catch (error) {
                    console.error("‚ö†Ô∏è Logout failed:", error.message);
                    showToast('Logout failed: ' + error.message, 'error');
                }
            }
            static onAuthStateChanged(callback) { return onAuthStateChanged(auth, callback); }
            static getCurrentUser() { return auth.currentUser; }
        }
        window.Auth = Auth;
        // ============================= 
        // üéØ MAIN APP CONTROLLER 
        // ============================= 
        class App {
            static _initialized = false;
            static async init() { if (this._initialized) return; this._initialized = true; console.log("üöÄ EduManage Single-Page App Initializing..."); if (document.readyState !== 'loading') this.onDOMReady(); else document.addEventListener('DOMContentLoaded', () => this.onDOMReady()); }
            static async onDOMReady() {
    // üëá WAIT for auth to complete BEFORE preloading
    await this.initializeAuth();

    // üëá NOW preload data (CURRENT_USER_ID is set)
    if (!window.location.pathname.includes('login.html')) {
        await Promise.all([
            DataCache.getBatches().catch(console.warn),
            DataCache.getStudents().catch(console.warn),
            DataCache.getFees().catch(console.warn)
        ]);

        this.setupNavigation();
        this.setupGlobalUI();
    }

    this.handleInitialRoute();
    window.addEventListener('hashchange', () => {
        const sectionId = location.hash.substring(1) || 'dashboard';
        this.showSection(sectionId);
    });
        // üëá HIDE GLOBAL LOADER AFTER EVERYTHING IS READY
    const globalLoader = document.getElementById('globalAppLoader');
    if (globalLoader) {
        globalLoader.style.opacity = '0';
        setTimeout(() => {
            globalLoader.style.display = 'none';
        }, 300);
    }
}
            static async initializeAuth() {
                return new Promise(resolve => {
                    Auth.onAuthStateChanged(async (user) => {
                        const isLoginPage = window.location.pathname.includes('login.html');

                        if (!user && !isLoginPage) {
                            window.location.href = 'login.html';
                            resolve();
                            return;
                        }

                        if (user && isLoginPage) {
                            window.location.href = 'index.html';
                            resolve();
                            return;
                        }

                        if (user && document.getElementById('user-email')) {
                            document.getElementById('user-email').textContent = user.email;
                            CURRENT_USER_ID = user.uid; // üëà Set BEFORE resolving
                            console.log("‚úÖ Authenticated as:", user.email, "| UID:", user.uid);
                        } else {
                            CURRENT_USER_ID = null;
                        }

                        resolve(); // üëà Resolve AFTER setting CURRENT_USER_ID
                    });
                });
            }
            static setupNavigation() {
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const target = e.target.closest('a').getAttribute('href').substring(1);
                        window.location.hash = target;

                        // üëá Auto-close sidebar on mobile after navigation
                        if (isMobile()) {
                            const sidebar = document.querySelector('.sidebar');
                            if (sidebar && sidebar.classList.contains('active')) {
                                sidebar.classList.remove('active');
                            }
                        }
                    });
                });
            }
            static setupGlobalUI() {
                const menuToggle = document.getElementById('menuToggle');
                const sidebar = document.querySelector('.sidebar');
                if (menuToggle && sidebar) {
                    menuToggle.addEventListener('click', () => sidebar.classList.toggle('active'));
                }
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('modal')) e.target.style.display = 'none';
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
                    }
                });
            }
           static async showSection(sectionId) {
    // Hide all sections first
    document.querySelectorAll('.section').forEach(sec => sec.classList.remove('active'));

    // Get target section
    const targetSection = document.getElementById(`${sectionId}-section`);
    if (targetSection) {
        targetSection.classList.add('active');

        // üëá SHOW LOADER IMMEDIATELY FOR DATA-HEAVY SECTIONS
        const loaderMap = {
            'dashboard': 'dashboard-loading',
            'students': 'students-loading',
            'batches': 'batches-loading',
            'fees': 'fees-loading',
            'all-students': 'all-students-loading'
        };

        const loaderId = loaderMap[sectionId];
        if (loaderId) {
            const loaderEl = document.getElementById(loaderId);
            if (loaderEl) {
                loaderEl.style.display = 'flex'; // üëà Show loader BEFORE init()
            }
        }
    }

    // Now initialize the section (which will hide loader when done)
    switch (sectionId) {
        case 'dashboard': await Dashboard.init(); break;
        case 'students': await Students.init(); break;
        case 'batches': await Batches.init(); break;
        case 'fees': await Fees.init(); break;
        case 'all-students': await AllStudents.init(); break;
    }

    // Update active nav link
    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
    const activeLink = document.querySelector(`.nav-link[href="#${sectionId}"]`);
    if (activeLink) activeLink.classList.add('active');
}
            static handleInitialRoute() {
                const hash = window.location.hash.substring(1);
                const sectionId = hash || 'dashboard';
                this.showSection(sectionId);
            }
            static getCurrentSection() {
                const hash = window.location.hash.substring(1) || 'dashboard';
                return hash;
            }
        }

        // ============================= 
        // üìä DASHBOARD MODULE 
        // ============================= 
        class Dashboard {
            static batchChart = null;
            static feeChart = null;
            static async init() {
                showLoading('dashboard'); // Show loading
                try {
                    await this.renderStats();
                    await this.renderCharts();
                    this.renderRecentActivity();
                    this.bindEvents();
                } catch (error) {
                    console.error("‚ùå Dashboard failed:", error);
                    showToast("Dashboard failed to load.", "error");
                } finally {
                    hideLoading('dashboard'); // Hide loading
                }
            }
            static bindEvents() {
                const refreshBtn = document.getElementById('refreshDashboard');
                if (refreshBtn) refreshBtn.addEventListener('click', async () => {
                    await this.renderStats();
                    this.renderCharts();
                    this.renderRecentActivity();
                });
            }
            static async renderStats() {
                try {
                    const [students, batches, fees] = await Promise.all([
                        DataCache.getStudents(),
                        DataCache.getBatches(),
                        DataCache.getFees()
                    ]);
                    document.getElementById('total-students').innerText = students.filter(s => !s.deleted).length;
                    document.getElementById('total-batches').innerText = batches.length;
                    const totalRevenue = fees.reduce((sum, f) => sum + (f.amountPaid || 0), 0);
                    document.getElementById('total-revenue').innerText = `‚Çπ${totalRevenue.toLocaleString()}`;
                    const pendingFees = fees.reduce((sum, f) => {
    if (f.hold) return sum; // üëà Skip held months
    const paid = f.amountPaid || 0;
    return sum + Math.max(0, (f.amount || 0) - paid);
}, 0);
                    document.getElementById('pending-fees').innerText = `‚Çπ${pendingFees.toLocaleString()}`;
                } catch (error) {
                    console.error(error);
                    showToast("Failed stats", "error");
                }
            }
            static async renderCharts() {
                await this.renderBatchDistributionChart();
                await this.renderFeeCollectionChart();
            }
            static async renderBatchDistributionChart() {
                try {
                    const [students, batches] = await Promise.all([
                        DataCache.getStudents(),
                        DataCache.getBatches()
                    ]);

                    // Create a map: batchId ‚Üí batchName
                    const batchMap = {};
                    batches.forEach(b => {
                        batchMap[b.id] = b.name || 'Unnamed Batch';
                    });

                    // Count students per batch, but store by NAME
                    const batchCounts = {};
                    students
                        .filter(s => !s.deleted && s.batch)
                        .forEach(s => {
                            const batchName = batchMap[s.batch] || 'Unknown Batch';
                            batchCounts[batchName] = (batchCounts[batchName] || 0) + 1;
                        });
                    const canvas = document.getElementById('batchDistributionChart');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    if (this.batchChart) this.batchChart.destroy();
                    this.batchChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(batchCounts),
                            datasets: [{
                                data: Object.values(batchCounts),
                                backgroundColor: ['#4361ee', '#3a0ca3', '#f72585', '#4cc9f0', '#4895ef', '#f8961e', '#7209b7', '#3f37c9'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { position: 'bottom', labels: { padding: 20, usePointStyle: true } },
                                tooltip: { callbacks: { label: ctx => `${ctx.label}: ${ctx.raw} students` } }
                            },
                            animation: { animateRotate: true, animateScale: true }
                        }
                    });
                } catch (error) {
                    console.error(error);
                }
            }
            static async renderFeeCollectionChart() {
    try {
        const fees = await DataCache.getFees();
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth(); // 0 = Jan, 11 = Dec

        // üëá Build list of last 3 months: [Aug, Sept, Oct] if now is Oct
        const last3Months = [];
        for (let i = 2; i >= 0; i--) { // Start from 2 months ago ‚Üí current month
            const monthOffset = currentMonth - i;
            let year = currentYear;
            let month = monthOffset;

            if (month < 0) {
                year -= 1;
                month += 12;
            }

            const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`; // "2025-10"
            const monthName = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][month];
            last3Months.push({
                key: monthKey,
                label: `${monthName} ${year}`,
                monthIndex: month,
                year: year
            });
        }

        // üëá Calculate total collected per month (only PAID fees, not held)
        const monthlyData = {};
        last3Months.forEach(m => monthlyData[m.key] = 0);

        fees.forEach(f => {
            if (!f.paid || f.hold) return; // Skip unpaid or held
            if (monthlyData.hasOwnProperty(f.month)) {
                monthlyData[f.month] += (f.amountPaid || 0);
            }
        });

        // üëá Prepare data for chart
        const labels = last3Months.map(m => m.label);
        const barData = last3Months.map(m => monthlyData[m.key]);
        const lineData = [...barData]; // Same values for trend line

        const canvas = document.getElementById('feeCollectionChart');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (this.feeChart) this.feeChart.destroy();

        this.feeChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        type: 'bar',
                        label: 'Monthly Collection (‚Çπ)',
                        data: barData,
                        backgroundColor: '#4361ee',
                        borderColor: '#3a0ca3',
                        borderWidth: 1,
                        borderRadius: 5,
                        borderSkipped: false,
                        datalabels: {
                            color: '#000',
                            font: { weight: 'bold', size: 12 },
                            formatter: (value) => '‚Çπ' + value.toLocaleString(),
                            anchor: 'end',
                            align: 'top',
                            offset: -4
                        }
                    },
                    {
                        type: 'line',
                        label: 'Trend',
                        data: lineData,
                        fill: false,
                        borderColor: '#e63946',
                        borderWidth: 3,
                        pointBackgroundColor: '#e63946',
                        pointRadius: 5,
                        tension: 0.3, // Smooth curve
                        yAxisID: 'y'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 20
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                if (ctx.dataset.type === 'line') {
                                    return `Trend: ‚Çπ${ctx.raw.toLocaleString()}`;
                                }
                                return `Collection: ‚Çπ${ctx.raw.toLocaleString()}`;
                            }
                        }
                    },
                    datalabels: {
                        display: true
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: (value) => '‚Çπ' + Math.floor(value).toLocaleString(),
                            font: { size: 11 }
                        },
                        title: {
                            display: true,
                            text: 'Amount Collected (‚Çπ)',
                            font: { size: 12 }
                        }
                    },
                    x: {
                        grid: { display: false },
                        title: {
                            display: true,
                            text: 'Last 3 Months',
                            font: { size: 12 }
                        }
                    }
                },
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart'
                }
            },
            plugins: [ChartDataLabels] // üëà Required for bar labels
        });

    } catch (error) {
        console.error("‚ùå Failed to render fee collection chart:", error);
    }
}
           static async renderRecentActivity() {
    try {
        const students = (await DataCache.getStudents())
            .filter(s => !s.deleted && s.createdAt) // üëà Only include if createdAt exists
            .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)) // üëà Sort by createdAt DESC
            .slice(0, 5); // üëà Take 5 most recent

        const list = document.getElementById('activity-list');
        if (!list) return;

        if (students.length === 0) {
            list.innerHTML = `<div style="text-align:center; padding:30px; color:#6c757d;"> <i class="fas fa-history" style="font-size:2rem; margin-bottom:10px;"></i> <p>No recent activity</p></div>`;
            return;
        }

        // Format "time ago" helper (optional but recommended)
        const formatTimeAgo = (dateStr) => {
            const now = new Date();
            const created = new Date(dateStr);
            const diffMs = now - created;
            const diffSec = Math.floor(diffMs / 1000);
            const diffMin = Math.floor(diffSec / 60);
            const diffHrs = Math.floor(diffMin / 60);
            const diffDays = Math.floor(diffHrs / 24);

            if (diffSec < 60) return `${diffSec}s ago`;
            if (diffMin < 60) return `${diffMin}m ago`;
            if (diffHrs < 24) return `${diffHrs}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return formatDate(dateStr); // fallback to full date
        };

        list.innerHTML = students.map(s => `
            <div class="activity-item">
                <div class="activity-icon bg-primary"><i class="fas fa-user-plus"></i></div>
                <div class="activity-content">
                    <h4>${s.name} added</h4>
                    <p>Added ${formatTimeAgo(s.createdAt)} ‚Ä¢ ${s.course}</p>
                </div>
            </div>
        `).join('');

    } catch (error) {
        console.error("‚ùå Failed to render recent activity:", error);
        showToast("Failed to load recent activity.", "error");
    }
}
        }

        // ============================= 
        // üë®‚Äçüéì STUDENTS MODULE 
        // ============================= 
        class Students {
            static async init() {
                this.bindEvents();
                await this.renderStudents();
            }
            static bindEvents() {
                document.getElementById('addStudentBtn')?.addEventListener('click', () => this.openAddStudentModal());
                document.getElementById('closeStudentModal')?.addEventListener('click', () => { document.getElementById('addStudentModal').style.display = 'none'; });
                document.getElementById('cancelStudentBtn')?.addEventListener('click', () => { document.getElementById('addStudentModal').style.display = 'none'; });
                document.getElementById('studentForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.saveStudent(); });
                document.getElementById('searchStudent')?.addEventListener('input', (e) => { this.filterStudents(e.target.value); });
                document.getElementById('filterByBatch')?.addEventListener('change', () => this.applyFilters());
                document.getElementById('filterByCourse')?.addEventListener('change', () => this.applyFilters());
                const tableBody = document.getElementById('studentsTableBody');
                if (tableBody) {
                    tableBody.addEventListener('click', async (e) => {
                        const editBtn = e.target.closest('.btn-edit-student');
                        if (editBtn) {
                            const id = editBtn.getAttribute('data-id');
                            const student = (await DataCache.getStudents()).find(s => s.id === id && !s.deleted);
                            if (student) this.openAddStudentModal(student);
                            else showToast('Student not found.', 'error');
                        }
                        const delBtn = e.target.closest('.btn-danger');
                        if (delBtn && delBtn.textContent.includes('Trash')) {
                            const match = delBtn.getAttribute('onclick')?.match(/'([^']+)'/);
                            if (match) await this.deleteStudent(match[1]);
                        }
                    });
                }
            }
        static async openAddStudentModal(student = null) {
    const modal = document.getElementById('addStudentModal');
    const form = document.getElementById('studentForm');
    const title = document.getElementById('studentModalTitle');
    form.reset();
    document.getElementById('studentId').value = '';

    if (student) {
        title.innerText = 'Edit Student';
        document.getElementById('studentId').value = student.id || '';
        document.getElementById('studentName').value = student.name || '';
        document.getElementById('fatherName').value = student.fatherName || '';

        // üëáüëáüëá FIX: Convert ISO date to YYYY-MM-DD for <input type="date">
        if (student.admissionDate) {
            const isoDate = new Date(student.admissionDate);
            if (!isNaN(isoDate.getTime())) {
                const year = isoDate.getFullYear();
                const month = String(isoDate.getMonth() + 1).padStart(2, '0');
                const day = String(isoDate.getDate()).padStart(2, '0');
                document.getElementById('admissionDate').value = `${year}-${month}-${day}`;
            } else {
                document.getElementById('admissionDate').value = ''; // fallback if invalid
            }
        } else {
            document.getElementById('admissionDate').value = '';
        }

        // Phone numbers
        if (student.phone && Array.isArray(student.phone)) {
            document.getElementById('phone').value = student.phone.join(', ');
        } else {
            document.getElementById('phone').value = '';
        }

        document.getElementById('course').value = student.course || '';
        document.getElementById('monthlyFee').value = student.monthlyFee || '';
    } else {
        title.innerText = 'Add New Student';
        document.getElementById('admissionDate').value = ''; // clear for new student
    }

    // Populate batch dropdown
    const batches = await DataCache.getBatches();
    const batchSelect = document.getElementById('batch');
    if (batchSelect) {
        batchSelect.innerHTML = '<option value="">Select Batch</option>';
        batches.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.id;
            opt.textContent = b.name;
            batchSelect.appendChild(opt);
            if (student && b.id === student.batch) opt.selected = true;
        });
    }

    modal.style.display = 'flex';
}
            static isSaving = false; // ‚Üê Add this at top of Students class

          static async saveStudent() {
    if (this.isSaving) {
        showToast('Please wait... saving in progress.', 'error');
        return;
    }

    this.isSaving = true;

    const form = document.getElementById('studentForm');
    const name = form.studentName.value.trim();
    const fatherName = form.fatherName.value.trim();
    const admissionDateStr = form.admissionDate.value.trim();
    if (!admissionDateStr) {
        showToast('Admission date is required.', 'error');
        this.isSaving = false;
        return;
    }

    // Validate date format and range
    const admissionDate = new Date(admissionDateStr);
    if (isNaN(admissionDate.getTime())) {
        showToast('Invalid admission date format.', 'error');
        this.isSaving = false;
        return;
    }

    // Define allowed range: Jan 1, 2024 ‚Üí Dec 31, 2026
    const minDate = new Date('2024-01-01');
    const maxDate = new Date('2026-12-31');

    if (admissionDate < minDate || admissionDate > maxDate) {
        showToast('Admission date must be between Jan 2024 and Dec 2026.', 'error');
        this.isSaving = false;
        return;
    }

    const admissionDateISO = admissionDate.toISOString(); // Use this for saving
    const course = form.course.value.trim();
    const batch = form.batch.value.trim();
    const monthlyFee = parseFloat(form.monthlyFee.value) || 0;

    if (!name || !fatherName || !admissionDate || !course || !batch) {
        showToast('Fill all required fields.', 'error');
        this.isSaving = false; // ‚Üê Unlock
        return;
    }

    // Parse and validate multiple phone numbers
    let phoneNumbers = [];
    const phoneInput = form.phone.value.trim();
    if (phoneInput) {
        const rawNumbers = phoneInput.split(',').map(p => p.trim());
        for (const num of rawNumbers) {
            if (num === '') continue;
            if (!/^[0-9]{10}$/.test(num)) {
                showToast(`Invalid phone number: "${num}". Must be exactly 10 digits.`, 'error');
                this.isSaving = false;
                return;
            }
            phoneNumbers.push(num);
        }
    }
    const phone = phoneNumbers.length > 0 ? phoneNumbers : null;

    const student = {
        name, fatherName, admissionDate: admissionDateISO, course, batch, monthlyFee,
        phone,
        createdAt: new Date().toISOString(),
        deleted: false
    };

    const studentId = form.studentId.value.trim();
    if (studentId) student.id = studentId;

    try {
        await FirebaseStorage.saveStudent(student);

        // üëáüëáüëá NEW: CLEAN UP OLD FEE RECORDS IF ADMISSION DATE MOVED FORWARD üëáüëáüëá
        if (student.id) {
            // Fetch existing student data to compare admission dates
            const existingStudents = await DataCache.getStudents();
            const existingStudent = existingStudents.find(s => s.id === student.id);

            if (existingStudent && existingStudent.admissionDate !== student.admissionDate) {
                const oldAdmission = new Date(existingStudent.admissionDate);
                const newAdmission = new Date(student.admissionDate);

                // Only clean up if new admission is LATER than old (forward shift)
                if (newAdmission > oldAdmission) {
                    console.log(`üìÖ Admission date moved forward from ${existingStudent.admissionDate} to ${student.admissionDate}. Cleaning up old fee records.`);

                    // Fetch all fees for this student
                    const allFees = await DataCache.getFees();
                    const studentFees = allFees.filter(f => f.studentId === student.id);

                    // Find fees that are BEFORE the new admission date
                    const feesToDelete = studentFees.filter(fee => {
                        const [year, month] = fee.month.split('-').map(Number); // "2023-05" ‚Üí [2023, 5]
                        const feeDate = new Date(year, month - 1, 1); // First day of fee month

                        return feeDate < newAdmission; // Keep only if fee month >= new admission
                    });

                    if (feesToDelete.length > 0) {
                        // Optional: Confirm with user
                        const confirmed = confirm(
                            `Admission date changed to ${formatDate(student.admissionDate)}.\n` +
                            `This will permanently delete ${feesToDelete.length} outdated fee records from before this date.\n` +
                            `Proceed?`
                        );

                        if (!confirmed) {
                            this.isSaving = false;
                            return; // Abort save if user cancels
                        }

                        showToast(`üßπ Deleting ${feesToDelete.length} outdated fee records...`, 'success');

                        // Batch delete outdated fees
                        const batch = writeBatch(db);
                        feesToDelete.forEach(fee => {
                            batch.delete(doc(db, "fees", fee.id));
                        });
                        await batch.commit();

                        // Refresh cache
                        DataCache.invalidate('fees');

                        showToast(`‚úÖ Deleted ${feesToDelete.length} outdated fee records.`, 'success');
                    }
                }
            }

            // üëáüëáüëá EXISTING LOGIC: Sync name, batch, course, and future unpaid fees üëáüëáüëá
            try {
                let fees = await DataCache.getFees();
                const studentFees = fees.filter(f => f.studentId === student.id);

                const today = new Date();

                for (const fee of studentFees) {
                    let updated = false;

                    // Sync name, batch, course
                    if (fee.studentName !== student.name) {
                        fee.studentName = student.name;
                        updated = true;
                    }
                    if (fee.batch !== student.batch) {
                        fee.batch = student.batch;
                        updated = true;
                    }
                    if (fee.course !== student.course) {
                        fee.course = student.course;
                        updated = true;
                    }

                    // Update amount ONLY for unpaid + current/future months
                    const feeMonthStart = new Date(fee.month + "-01"); // e.g., "2024-06" ‚Üí Jun 1, 2024
                    if (
                        student.monthlyFee &&
                        !fee.paid &&
                        feeMonthStart >= new Date(today.getFullYear(), today.getMonth(), 1) &&
                        fee.amount !== student.monthlyFee
                    ) {
                        fee.amount = student.monthlyFee;
                        updated = true;
                    }

                    if (updated) {
                        await FirebaseStorage.saveFee(fee);
                    }
                }

                // Force reload fees cache
                DataCache.invalidate('fees');

                // If user is on Fees tab, refresh UI immediately
                if (App.getCurrentSection() === 'fees') {
                    await Fees.renderFeeRecords();
                }

            } catch (err) {
                console.warn("‚ö†Ô∏è Could not update fee records after student edit:", err);
                // Don't break flow ‚Äî student was still saved successfully
            }
        }
        // üëÜüëÜüëÜ END OF PATCH BLOCK üëÜüëÜüëÜ

        DataCache.invalidate('students');
        DataCache.invalidate('fees');
        showToast('Student saved!', 'success');
        await this.renderStudents();
        this.closeAddStudentModal();
    } catch (error) {
        console.error(error);
        showToast('Failed to save student.', 'error');
    } finally {
        this.isSaving = false; // ‚Üê Always unlock
    }
}
            static closeAddStudentModal() {
                document.getElementById('addStudentModal').style.display = 'none';
            }
            static async renderStudents(filterText = '', batchFilter = '', courseFilter = '') {
                showLoading('students');
                try {
                    let students = (await DataCache.getStudents()).filter(s => !s.deleted);

                    // >>> NEW: Create Batch ID ‚Üí Name Map <<<
                    const batches = await DataCache.getBatches();
                    const batchMap = {};
                    batches.forEach(b => {
                        batchMap[b.id] = b.name || 'Unnamed Batch';
                    });

                    // >>> Populate Batch Filter <<<
                    const batchSelect = document.getElementById('filterByBatch');
                    if (batchSelect) {
                        batchSelect.innerHTML = '<option value="">All Batches</option>';
                        batches.forEach(b => {
                            const opt = document.createElement('option');
                            opt.value = b.id;
                            opt.textContent = b.name || 'Unnamed Batch';
                            if (b.id === batchFilter) opt.selected = true;
                            batchSelect.appendChild(opt);
                        });
                    }

                    // >>> Populate Course Filter <<<
                    const courseSelect = document.getElementById('filterByCourse');
                    if (courseSelect) {
                        const uniqueCourses = [...new Set(students.map(s => s.course).filter(Boolean))];
                        courseSelect.innerHTML = '<option value="">All Courses</option>';
                        uniqueCourses.forEach(course => {
                            const opt = document.createElement('option');
                            opt.value = course;
                            opt.textContent = course;
                            if (course === courseFilter) opt.selected = true;
                            courseSelect.appendChild(opt);
                        });
                    }

                    // Apply search filter
                    if (filterText) {
                        const term = filterText.toLowerCase();
                        students = students.filter(s =>
                            (s.name?.toLowerCase().includes(term)) ||
                            (s.fatherName?.toLowerCase().includes(term))
                        );
                    }

                    // Apply batch filter
                    if (batchFilter) students = students.filter(s => s.batch === batchFilter);

                    // Apply course filter
                    if (courseFilter) students = students.filter(s => s.course === courseFilter);

                    const tbody = document.getElementById('studentsTableBody');
                    if (!tbody) return;

                    if (students.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="8">No active students found.</td></tr>';
                        return;
                    }

                    // Render table rows with readable batch names
                    tbody.innerHTML = students.map(s => `
            <tr>
                <td>${s.id?.substring(0, 6).toUpperCase() || '‚Äî'}</td>
                <td>${s.name || '‚Äî'}</td>
                <td>${s.fatherName || '‚Äî'}</td>
                <td>${s.course || '‚Äî'}</td>
                <td>${batchMap[s.batch] || '‚Äî'}</td> <!-- üëà FIXED: Show batch NAME instead of ID -->
                <td>‚Çπ${(s.monthlyFee || 0).toLocaleString()}</td>
                <td>${formatDate(s.admissionDate) || '‚Äî'}</td>
                <td>
                    <button class="btn btn-sm btn-primary btn-edit-student" data-id="${s.id}">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="btn btn-sm btn-danger" onclick="Students.deleteStudent('${s.id}')">
                        <i class="fas fa-trash"></i>
                    </button>
                </td>
            </tr>
        `).join('');

                } catch (error) {
                    console.error(error);
                    showToast('Failed to load students.', 'error');
                } finally {
                    hideLoading('students'); // Hide loading
                }
            }
            static filterStudents(query) {
                const b = document.getElementById('filterByBatch')?.value || '';
                const c = document.getElementById('filterByCourse')?.value || '';
                this.renderStudents(query, b, c);
            }
            static applyFilters() {
                const q = document.getElementById('searchStudent')?.value || '';
                const b = document.getElementById('filterByBatch')?.value || '';
                const c = document.getElementById('filterByCourse')?.value || '';
                this.renderStudents(q, b, c);
            }
            static async deleteStudent(id) {
                if (!confirm('Archive this student? They‚Äôll be hidden but preserved.')) return;
                try {
                    await FirebaseStorage.archiveStudent(id);
                    DataCache.invalidate('students');
                    showToast('Student archived!', 'success');
                    await this.renderStudents();
                } catch (error) {
                    console.error(error);
                    showToast('Failed to archive.', 'error');
                }
            }
        }

        // ============================= 
        // üìö BATCHES MODULE 
        // ============================= 
        class Batches {
            static async init() {
                this.bindEvents();
                await this.renderBatchSelector();
            }
            static bindEvents() {
                document.getElementById('addBatchBtn')?.addEventListener('click', () => this.openAddBatchModal());
                document.getElementById('batchSelector')?.addEventListener('change', (e) => this.loadBatchDetails(e.target.value));
                document.getElementById('deleteBatchBtn')?.addEventListener('click', () => this.deleteCurrentBatch());
                document.getElementById('batchForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.saveBatch(); });
                document.getElementById('closeBatchModal')?.addEventListener('click', () => this.closeBatchModal());
                document.getElementById('cancelBatchBtn')?.addEventListener('click', () => this.closeBatchModal());
                document.getElementById('updateStudentBatchForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.updateStudentBatch(); });
                document.getElementById('cancelUpdateBatchBtn')?.addEventListener('click', () => this.closeUpdateStudentBatchModal());
                document.getElementById('closeUpdateBatchModal')?.addEventListener('click', () => this.closeUpdateStudentBatchModal());
            }
            static async renderBatchSelector() {
                showLoading('batches');
                try {
                    const selector = document.getElementById('batchSelector');
                    if (!selector) return;
                    selector.innerHTML = '<option value="">Loading...</option>';
                    selector.disabled = true;
                    const batches = await DataCache.getBatches();
                    selector.disabled = false;
                    selector.innerHTML = batches.length === 0 ? '<option value="">No batches ‚Äî add one</option>' : '<option value="">Select a Batch</option>';
                    batches.forEach(b => {
                        const opt = document.createElement('option');
                        opt.value = b.id;
                        opt.textContent = b.name || 'Unnamed';
                        selector.appendChild(opt);
                    }); const newBatchSelect = document.getElementById('newBatch');
                    if (newBatchSelect) {
                        newBatchSelect.innerHTML = '<option value="">Select Batch</option>';
                        batches.forEach(b => {
                            const opt = document.createElement('option');
                            opt.value = b.id;
                            opt.textContent = b.name;
                            newBatchSelect.appendChild(opt);
                        });
                    }
                    if (batches.length === 1) {
                        selector.value = batches[0].id;
                        this.loadBatchDetails(batches[0].id);
                    }
                } catch (error) {
                    console.error(error);
                    showToast("Failed to load batches.", "error");
                } finally {
                    hideLoading('batches'); // Hide loading
                }
            }

            static async loadBatchDetails(batchId) {
                if (!batchId) {
                    this.clearBatchDetails();
                    return;
                }
                showLoading('batches');
                try {
                    const [students, batches] = await Promise.all([
                        DataCache.getStudents(),
                        DataCache.getBatches()
                    ]);

                    const batchStudents = students.filter(s => s.batch === batchId && !s.deleted);
                    const uniqueCourses = [...new Set(batchStudents.map(s => s.course))];

                    const batch = batches.find(b => b.id === batchId);

                    document.getElementById('batchName').textContent = batch?.name || '-';
                    document.getElementById('batchStudentCount').textContent = batchStudents.length;
                    document.getElementById('batchCourses').textContent = uniqueCourses.join(', ') || '-';

                    this.renderStudentsInBatch(batchStudents);
                } catch (error) {
                    console.error("‚ùå Failed to load batch details:", error);
                    showToast("Failed to load batch details.", "error");
                } finally {
                    hideLoading('batches'); // Hide loading
                }
            }

            static clearBatchDetails() {
                document.getElementById('batchName').textContent = '-';
                document.getElementById('batchStudentCount').textContent = '0';
                document.getElementById('batchCourses').textContent = '-';
                document.getElementById('batchStudentsTable').innerHTML = `
            <tr>
                <td colspan="6" class="no-data">Select a batch to view students.</td>
            </tr>
        `;
            }

           static renderStudentsInBatch(students) {
    const tbody = document.getElementById('batchStudentsTable');
    if (!tbody) return;

    if (students.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="6" class="no-data">No students in this batch.</td>
            </tr>
        `;
        return;
    }

    tbody.innerHTML = students.map((student, index) => `
        <tr>
            <td>${index + 1}</td> <!-- üëà SERIAL NUMBER -->
            <td>${student.name}</td>
            <td>${student.course}</td>
            <td>‚Çπ${(student.monthlyFee || 0).toLocaleString()}</td>
            <td>${formatDate(student.admissionDate)}</td>
            <td>
                <button class="btn btn-sm btn-primary" onclick="Batches.openUpdateStudentBatchModal('${student.id}')">
                    <i class="fas fa-exchange-alt"></i> Change Batch
                </button>
            </td>
        </tr>
    `).join('');
}
            static openAddBatchModal(batch = null) {
                const modal = document.getElementById('addBatchModal');
                const form = document.getElementById('batchForm');
                const title = document.getElementById('batchModalTitle');

                form.reset();
                document.getElementById('batchId').value = '';

                if (batch) {
                    title.innerText = 'Edit Batch';
                    document.getElementById('batchId').value = batch.id || '';
                    document.getElementById('batchNameInput').value = batch.name || '';
                    document.getElementById('batchTiming').value = batch.timing || '';
                } else {
                    title.innerText = 'Add New Batch';
                }

                modal.style.display = 'flex';
            }

            static closeBatchModal() {
                document.getElementById('addBatchModal').style.display = 'none';
            }

            static isSaving = false; // ‚Üê Add at top of Batches class

            static async saveBatch() {
                if (this.isSaving) {
                    showToast('Please wait... saving in progress.', 'error');
                    return;
                }

                this.isSaving = true;

                const form = document.getElementById('batchForm');
                const batchName = form.batchName.value.trim();
                const timing = form.timing.value.trim();
                const batchId = form.batchId.value.trim();

                if (!batchName) {
                    showToast('Batch name is required.', 'error');
                    this.isSaving = false;
                    return;
                }

                const batchObj = {
                    name: batchName,
                    timing: timing || '',
                    createdAt: new Date().toISOString()
                };

                try {
                    let result;
                    if (batchId) {
                        batchObj.id = batchId;
                        result = await FirebaseStorage.saveBatch(batchObj);
                        showToast('Batch updated successfully!', 'success');
                    } else {
                        result = await FirebaseStorage.saveBatch(batchObj);
                        showToast('Batch added successfully!', 'success');
                    }

                    // üëá CRITICAL FIX: Invalidate cache BEFORE reloading
                    DataCache.invalidate('batches');

                    // üëá Wait for fresh data to be loaded
                    await this.renderBatchSelector();

                    this.closeBatchModal();

                    // If this was a new batch, auto-select it
                    if (!batchId && result?.id) {
                        const selector = document.getElementById('batchSelector');
                        if (selector) {
                            selector.value = result.id;
                            await this.loadBatchDetails(result.id);
                        }
                    } else {
                        // For edit, refresh current batch if it's the one being edited
                        const currentBatchId = document.getElementById('batchSelector')?.value;
                        if (currentBatchId === (result.id || batchId)) {
                            await this.loadBatchDetails(currentBatchId);
                        }
                    }

                } catch (error) {
                    console.error("‚ùå Failed to save batch:", error);
                    showToast('Failed to save batch: ' + (error.message || 'Unknown error'), 'error');
                } finally {
                    this.isSaving = false;
                }
            }

            static async deleteCurrentBatch() {
                const selector = document.getElementById('batchSelector');
                const batchId = selector.value;

                if (!batchId) {
                    showToast('Please select a batch to delete.', 'error');
                    return;
                }

                if (!confirm(`Are you sure you want to delete this batch? Students will retain the batch ID until reassigned.`)) {
                    return;
                }

                try {
                    await FirebaseStorage.deleteBatch(batchId);
                    showToast('Batch deleted successfully!', 'success');

                    // üëá CRITICAL: Invalidate BEFORE reloading
                    DataCache.invalidate('batches');

                    // üëá Wait for fresh data and re-render selector
                    await this.renderBatchSelector();

                    // üëá Clear current batch details (since deleted batch shouldn't be shown)
                    this.clearBatchDetails();

                    // üëá Auto-select first batch if any exists
                    const selector = document.getElementById('batchSelector');
                    if (selector && selector.options.length > 1) { // >1 because first is placeholder
                        selector.selectedIndex = 1; // Select first real batch
                        await this.loadBatchDetails(selector.value);
                    }

                } catch (error) {
                    console.error("‚ùå Failed to delete batch:", error);
                    showToast('Failed to delete batch: ' + error.message, 'error');
                }
            }

            static openUpdateStudentBatchModal(studentId) {
                document.getElementById('updateStudentId').value = studentId;
                document.getElementById('updateStudentBatchModal').style.display = 'flex';
            }

            static closeUpdateStudentBatchModal() {
                document.getElementById('updateStudentBatchModal').style.display = 'none';
            }

            static async updateStudentBatch() {
                const studentId = document.getElementById('updateStudentId').value;
                const newBatchId = document.getElementById('newBatch').value;

                if (!newBatchId) {
                    showToast('Please select a batch.', 'error');
                    return;
                }

                try {
                    const students = await DataCache.getStudents();
                    const studentIndex = students.findIndex(s => s.id === studentId);

                    if (studentIndex === -1) {
                        showToast('Student not found.', 'error');
                        return;
                    }

                    students[studentIndex].batch = newBatchId;
                    await FirebaseStorage.saveStudent(students[studentIndex]);

                    DataCache.invalidate('students');

                    showToast('Student batch updated successfully!', 'success');
                    this.closeUpdateStudentBatchModal();

                    const currentBatchId = document.getElementById('batchSelector').value;
                    if (currentBatchId) {
                        await this.loadBatchDetails(currentBatchId);
                    }
                } catch (error) {
                    console.error("‚ùå Failed to update student batch:", error);
                    showToast('Failed to update student batch: ' + error.message, 'error');
                }
            }
        }

        // =============================
        // üí∞ FEES MODULE (PATCHED FOR PERFORMANCE)
        // =============================
        class Fees {
            static currentSyncPromise = null; // ‚Üê Prevent duplicate syncs
            static isRecording = false;


static async init() {
    console.log("üöÄ Fees.init() starting...");

    if (document.readyState === 'loading') {
        await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));
    }

    // Populate year filter FIRST
    this.populateYearFilter();
    await new Promise(r => setTimeout(r, 50)); // Let DOM settle

    const now = new Date();
    const currentMonthStr = String(now.getMonth());
    const currentYearStr = String(now.getFullYear());

    const monthFilter = document.getElementById('monthFilter');
    const yearFilter = document.getElementById('yearFilter');

    let filtersChanged = false;

    if (monthFilter && monthFilter.value === "") {
        monthFilter.value = currentMonthStr;
        filtersChanged = true;
    }

    if (yearFilter && yearFilter.value === "") {
        const optionExists = [...yearFilter.options].some(opt => opt.value === currentYearStr);
        if (optionExists) {
            yearFilter.value = currentYearStr;
            yearFilter.dispatchEvent(new Event('change'));
            filtersChanged = true;
        }
    }

    // üëáüëá PATCH 1: FORCE SYNC BEFORE RENDERING üëáüëá
    showToast("‚è≥ Preparing fee records...", "success");
    await this.ensureFeeRecordsForAllStudents(); // ‚Üê Wait for sync to complete

    if (filtersChanged) {
        console.log("üîÑ Filters changed ‚Äî applying...");
        this.applyFilters();
    } else {
        console.log("üìä Rendering all records...");
        await this.renderFeeRecords(); // ‚Üê Now safe ‚Äî data exists
    }

    this.bindEvents();
    console.log("‚úÖ Fees.init() completed.");
}
            static startBackgroundSync() {
                if (this.currentSyncPromise) {
                    return this.currentSyncPromise;
                }
                this.currentSyncPromise = (async () => {
                    try {
                        await this.ensureFeeRecordsForAllStudents();
                    } finally {
                        this.currentSyncPromise = null;
                    }
                })();
                return this.currentSyncPromise;
            }

      static async ensureFeeRecordsForAllStudents() {
    const statusEl = document.getElementById('feeSyncStatus');
    let progressToast = null;

    if (statusEl) statusEl.style.display = 'block';
    showToast("üîÑ Starting background fee sync...", "success");

    try {
        const [students, fees] = await Promise.all([
            DataCache.getStudents(),
            DataCache.getFees()
        ]);

        const today = new Date();
        const currentYear = today.getFullYear();
        const currentMonth = today.getMonth();
        const existingKeys = new Set(fees.map(f => `${f.studentId}-${f.month}`));
        const newFeesToCreate = [];

        for (const student of students.filter(s => !s.deleted)) {
            const admissionDate = new Date(student.admissionDate);
            if (isNaN(admissionDate)) continue;

            const admissionDay = admissionDate.getDate();

            for (let year = admissionDate.getFullYear(); year <= currentYear; year++) {
                const startMonth = (year === admissionDate.getFullYear()) ? admissionDate.getMonth() : 0;
                const endMonth = (year === currentYear) ? currentMonth : 11;

                for (let m = startMonth; m <= endMonth; m++) {
                    const monthKey = `${year}-${String(m + 1).padStart(2, '0')}`;
                    const compositeKey = `${student.id}-${monthKey}`;
                    if (existingKeys.has(compositeKey)) continue;

                    // üëá ONLY create if today >= billing date (admission day of this month)
                    const billingDate = new Date(year, m, admissionDay);
                    if (today < billingDate) continue;

                    newFeesToCreate.push({
                        studentId: student.id,
                        studentName: student.name,
                        month: monthKey,
                        amount: student.monthlyFee || 0,
                        amountPaid: 0,
                        paid: false,
                        paidDate: null,
                        batch: student.batch,
                        course: student.course,
                        ownerId: CURRENT_USER_ID
                    });
                }
            }
        }

        if (newFeesToCreate.length === 0) {
            showToast("‚úÖ No missing fee records. All synced!", "success");
            return;
        }

        showToast(`üÜï Found ${newFeesToCreate.length} missing fee records.`, "success");

        const BATCH_LIMIT = 400;
        for (let i = 0; i < newFeesToCreate.length; i += BATCH_LIMIT) {
            const batchIndex = Math.floor(i / BATCH_LIMIT) + 1;
            const sub = newFeesToCreate.slice(i, i + BATCH_LIMIT);

            const batch = writeBatch(db);
            sub.forEach(fee => {
                const newDocRef = doc(collection(db, "fees"));
                batch.set(newDocRef, fee);
            });

            await batch.commit();
            console.log(`‚úÖ Batch ${batchIndex}: ${sub.length} records committed`);
        }

        DataCache.invalidate("fees");
        showToast(`üéâ Sync complete! Added ${newFeesToCreate.length} records.`, 'success');

    } catch (error) {
        console.error("‚ùå Sync failed:", error);
        showToast(`‚ùå Fee sync failed: ${error.message}`, "error");
    } finally {
        if (statusEl) statusEl.style.display = 'none';
    }
}
          static async ensureFeeRecordsForStudent(studentId, studentData) {
    try {
        const fees = await DataCache.getFees();
        const existingKeys = new Set(fees.map(f => `${f.studentId}-${f.month}`));

        const today = new Date();
        const currentYear = today.getFullYear();
        const currentMonth = today.getMonth();

        const admissionDate = new Date(studentData.admissionDate);
        if (isNaN(admissionDate)) return [];

        const admissionDay = admissionDate.getDate();
        const newFeesToCreate = [];

        for (let year = admissionDate.getFullYear(); year <= currentYear; year++) {
            const startMonth = (year === admissionDate.getFullYear()) ? admissionDate.getMonth() : 0;
            const endMonth = (year === currentYear) ? currentMonth : 11;

           for (let m = startMonth; m <= endMonth; m++) {
    const monthKey = `${year}-${String(m + 1).padStart(2, '0')}`;
    const compositeKey = `${studentId}-${monthKey}`;
    if (existingKeys.has(compositeKey)) continue;

    // üëá PATCH: Remove day-based skip for PAST/CURRENT months
    // Only skip if ENTIRE MONTH is in future
    if (year > currentYear || (year === currentYear && m > currentMonth)) {
        continue; // Skip only future months
    }

    // For past/current months ‚Üí ALWAYS generate record
    newFeesToCreate.push({
        studentId,
        studentName: studentData.name,
        month: monthKey,
        amount: studentData.monthlyFee || 0,
        amountPaid: 0,
        paid: false,
        paidDate: null,
        batch: studentData.batch,
        course: studentData.course,
        ownerId: CURRENT_USER_ID
    });
}
        }

        if (newFeesToCreate.length > 0) {
            const batch = writeBatch(db);
            newFeesToCreate.forEach(fee => {
                const newDocRef = doc(collection(db, "fees"));
                batch.set(newDocRef, fee);
            });
            await batch.commit();
            DataCache.invalidate("fees");
        }

        return newFeesToCreate;
    } catch (error) {
        console.error("‚ùå Failed to ensure fee records for student:", error);
        throw error;
    }
}

            static bindEvents() {
                document.getElementById('payFeeBtn')?.addEventListener('click', () => this.openPayFeeModal());
                document.getElementById('payFeeForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.recordPayment(); });
                document.getElementById('cancelPayFeeBtn')?.addEventListener('click', () => this.closePayFeeModal());
                document.getElementById('closePayFeeModal')?.addEventListener('click', () => this.closePayFeeModal());
                document.getElementById('closeViewPaymentModal')?.addEventListener('click', () => this.closeViewPaymentModal());
                document.getElementById('closeViewPaymentBtn')?.addEventListener('click', () => this.closeViewPaymentModal());

                document.getElementById('studentSelect')?.addEventListener('change', (e) => this.updateAmountDue(e.target.value));

                document.getElementById('feeSearch')?.addEventListener('input', (e) => this.applyFilters(e.target.value));
                document.getElementById('feeStatusFilter')?.addEventListener('change', () => this.applyFilters());
                document.getElementById('monthFilter')?.addEventListener('change', () => this.applyFilters());
                document.getElementById('yearFilter')?.addEventListener('change', () => this.applyFilters());
document.getElementById('downloadExcelBtn')?.addEventListener('click', () => {
    Fees.downloadAllDataAsExcel();
});
                this.populateYearFilter();
                this.populateStudentSelect();
              document.getElementById('holdPaymentCheckbox')?.addEventListener('change', (e) => {
    const isChecked = e.target.checked;
    const selectorDiv = document.getElementById('holdMonthSelectors');
    const monthSelect = document.getElementById('holdMonthSelect');
    const yearSelect = document.getElementById('holdYearSelect');
    const paymentFields = document.getElementById('paymentFields');
    const amountPaidInput = document.getElementById('amountPaid');
    const submitBtn = document.querySelector('#payFeeForm .btn-primary');
    const notesLabel = document.querySelector('label[for="paymentNotes"]');

    if (isChecked) {
        // SHOW hold selectors
        selectorDiv.style.display = 'block';
        monthSelect.disabled = false;
        yearSelect.disabled = false;

        // DISABLE payment fields
        if (paymentFields) paymentFields.style.opacity = '0.6';
        if (amountPaidInput) {
            amountPaidInput.disabled = true;
            amountPaidInput.value = ''; // clear if any
        }

        // Update UI text
        if (notesLabel) notesLabel.textContent = 'Hold Reason (Optional)';
        if (submitBtn) submitBtn.textContent = 'Apply Hold';

        // Auto-set current month/year
        const now = new Date();
        monthSelect.value = now.getMonth();
        yearSelect.value = now.getFullYear();

    } else {
        // HIDE hold selectors
        selectorDiv.style.display = 'none';
        monthSelect.disabled = true;
        yearSelect.disabled = true;

        // ENABLE payment fields
        if (paymentFields) paymentFields.style.opacity = '1';
        if (amountPaidInput) {
            amountPaidInput.disabled = false;
        }

        // Reset UI text
        if (notesLabel) notesLabel.textContent = 'Notes (Optional)';
        if (submitBtn) submitBtn.textContent = 'Record Payment';
    }

    // Re-calculate due amount
    const studentId = document.getElementById('studentSelect').value;
    if (studentId) {
        Fees.updateAmountDue(studentId);
    }
});
            }

          static populateYearFilter() {
    const currentYear = new Date().getFullYear();
    const years = [];
    for (let i = currentYear - 2; i <= currentYear + 1; i++) {
        years.push(i);
    }

    const selectors = document.querySelectorAll('#yearFilter, #feeYear');
    selectors.forEach(select => {
        if (!select) return;

        select.innerHTML = '';

        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select Year';
        select.appendChild(placeholder);

        let currentYearOption = null;

        years.forEach(year => {
            const option = document.createElement('option');
            option.value = String(year);
            option.textContent = String(year);
            select.appendChild(option);
            if (year === currentYear) currentYearOption = option;
        });

        // üëá OPTIONAL: Pre-select current year if nothing selected yet
        if (select.value === "" && currentYearOption) {
            select.value = String(currentYear);
            select.dispatchEvent(new Event('change')); // üëà Force UI update
        }
    });
}
            static populateHoldYearSelect() {
    const currentYear = new Date().getFullYear();
    const years = [];
    for (let i = currentYear - 2; i <= currentYear + 1; i++) {
        years.push(i);
    }

    const select = document.getElementById('holdYearSelect');
    if (!select) return;

    select.innerHTML = '<option value="">Select Year</option>';
    years.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        select.appendChild(option);
    });
}
static openPayFeeModal() {
    this.populateStudentSelect();
    this.populateHoldYearSelect(); // ‚Üê Populate year dropdown

    document.getElementById('payFeeForm').reset();
    document.getElementById('amountDue').value = 0;

    // Reset hold UI state
    const holdCheckbox = document.getElementById('holdPaymentCheckbox');
    const selectorDiv = document.getElementById('holdMonthSelectors');
    const monthSelect = document.getElementById('holdMonthSelect');
    const yearSelect = document.getElementById('holdYearSelect');

    if (holdCheckbox) holdCheckbox.checked = false;
    if (selectorDiv) selectorDiv.style.display = 'none';
    if (monthSelect) monthSelect.disabled = true;
    if (yearSelect) yearSelect.disabled = true;

    document.getElementById('payFeeModal').style.display = 'flex';
}
            static async populateStudentSelect(includeArchived = false) {
                try {
                    let students = await DataCache.getStudents();
                    if (!includeArchived) {
                        students = students.filter(s => !s.deleted);
                    }

                    const select = document.getElementById('studentSelect');
                    if (!select) return;

                    select.innerHTML = '<option value="">Select Student</option>';
                    if (students.length === 0) {
                        const opt = document.createElement('option');
                        opt.value = '';
                        opt.textContent = includeArchived ? 'No students found' : 'No active students found';
                        opt.disabled = true;
                        select.appendChild(opt);
                        return;
                    }

                    students.forEach(student => {
                        const option = document.createElement('option');
                        option.value = student.id;
                        option.textContent = `${student.name} (${student.course || 'No Course'})${student.deleted ? ' (Archived)' : ''}`;
                        option.dataset.monthlyFee = student.monthlyFee || 0;
                        if (student.deleted) {
                            option.style.color = '#dc3545'; // Red text for archived
                        }
                        select.appendChild(option);
                    });
                } catch (error) {
                    console.error("Failed to populate student select:", error);
                    showToast("Could not load student list. Please refresh.", "error");
                    const select = document.getElementById('studentSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Error loading students</option>';
                    }
                }
            }

          static async updateAmountDue(studentId) {
    if (!studentId) {
        document.getElementById('amountDue').value = 0;
        return;
    }

    try {
        const fees = await DataCache.getFees();
        const holdChecked = document.getElementById('holdPaymentCheckbox')?.checked || false;

       let studentFees = fees.filter(f =>
    f.studentId === studentId &&
    !f.paid &&
    !f.hold
);

// Get student to check admission day
const students = await DataCache.getStudents();
const student = students.find(s => s.id === studentId);
if (student && student.admissionDate) {
    const admissionDay = new Date(student.admissionDate).getDate();

    studentFees = studentFees.filter(fee => {
        const [yearStr, monthStr] = fee.month.split('-');
        const billingDate = new Date(parseInt(yearStr), parseInt(monthStr) - 1, admissionDay);
        const today = new Date();

        // Include if billing date has passed (even if not paid)
        return today >= billingDate;
    });
}

        // If holding a SPECIFIC month, exclude THAT month
        if (holdChecked) {
            const holdMonth = document.getElementById('holdMonthSelect')?.value;
            const holdYear = document.getElementById('holdYearSelect')?.value;

            if (holdMonth !== '' && holdYear !== '') {
                const holdMonthStr = `${holdYear}-${String(Number(holdMonth) + 1).padStart(2, '0')}`;
                studentFees = studentFees.filter(f => f.month !== holdMonthStr);
            }
            // If not selected yet, don't filter ‚Äî wait for user input
        }

        const totalDue = studentFees.reduce((sum, f) => sum + (f.amount - (f.amountPaid || 0)), 0);
        document.getElementById('amountDue').value = totalDue;

    } catch (error) {
        console.error("Failed to calculate due amount:", error);
        showToast("Failed to load due amount.", "error");
    }
}
          static openPayFeeModal() {
    this.populateStudentSelect();
    this.populateHoldYearSelect(); // ‚Üê Populate year dropdown

    document.getElementById('payFeeForm').reset();
    document.getElementById('amountDue').value = 0;

    // Reset hold UI state
    const holdCheckbox = document.getElementById('holdPaymentCheckbox');
    const selectorDiv = document.getElementById('holdMonthSelectors');
    const monthSelect = document.getElementById('holdMonthSelect');
    const yearSelect = document.getElementById('holdYearSelect');

    if (holdCheckbox) holdCheckbox.checked = false;
    if (selectorDiv) selectorDiv.style.display = 'none';
    if (monthSelect) monthSelect.disabled = true;
    if (yearSelect) yearSelect.disabled = true;

    document.getElementById('payFeeModal').style.display = 'flex';
}

            static closePayFeeModal() {
                document.getElementById('payFeeModal').style.display = 'none';
            }

            static closeViewPaymentModal() {
                document.getElementById('viewPaymentModal').style.display = 'none';
            }

          static async recordPayment() {
    if (this.isRecording) {
        showToast('Payment recording in progress. Please wait.', 'error');
        return;
    }

    this.isRecording = true;

    const studentId = document.getElementById('studentSelect').value;
    const amountDue = parseFloat(document.getElementById('amountDue').value);
    const amountPaid = parseFloat(document.getElementById('amountPaid').value);
    const paymentMethod = document.getElementById('paymentMethod').value;
    const paymentNotes = document.getElementById('paymentNotes').value.trim();
   const holdChecked = document.getElementById('holdPaymentCheckbox')?.checked || false;

if (!studentId) {
    showToast('Please select a student.', 'error');
    this.isRecording = false;
    return;
}

// üëá ONLY validate amountPaid if NOT holding
if (!holdChecked) {
    if (isNaN(amountDue) || isNaN(amountPaid) || amountPaid < 0) {
        showToast('Please enter a valid payment amount.', 'error');
        this.isRecording = false;
        return;
    }
}

    try {
        // Ensure student exists
        const students = await DataCache.getStudents();
        const studentData = students.find(s => s.id === studentId);
        if (!studentData) throw new Error("Student not found.");

        // Ensure fee records exist for student
        await this.ensureFeeRecordsForStudent(studentId, studentData);

        // üëá HANDLE HOLDING SPECIFIC MONTH
        if (holdChecked) {
            const holdMonth = document.getElementById('holdMonthSelect')?.value;
            const holdYear = document.getElementById('holdYearSelect')?.value;

            if (holdMonth === '' || holdYear === '') {
                showToast('Please select a month and year to hold.', 'error');
                this.isRecording = false;
                return;
            }

            const holdMonthKey = `${holdYear}-${String(Number(holdMonth) + 1).padStart(2, '0')}`; // "2025-06"

            // Fetch that specific fee record
            let fees = await DataCache.getFees();
            const targetFee = fees.find(f =>
                f.studentId === studentId &&
                f.month === holdMonthKey
            );

            if (!targetFee) {
                showToast(`No fee record found for ${this.formatMonthYear(holdMonthKey)}.`, 'error');
                this.isRecording = false;
                return;
            }

            if (targetFee.paid) {
                showToast(`Cannot hold ${this.formatMonthYear(holdMonthKey)} ‚Äî already paid.`, 'error');
                this.isRecording = false;
                return;
            }

            // Mark as held
            targetFee.hold = true;
            targetFee.holdReason = paymentNotes || 'Held during payment';
            targetFee.holdDate = new Date().toISOString();

            await FirebaseStorage.saveFee(targetFee);
            console.log(`‚è∏Ô∏è Month ${targetFee.month} manually held for student ${studentId}`);

            // Refresh cache so it's excluded from payment allocation
            fees = await DataCache.getFees();
        }

        // üëá APPLY PAYMENT TO REMAINING UNPAID, NON-HELD FEES (oldest first)
       // üëá ONLY APPLY PAYMENT IF NOT HOLDING
if (!holdChecked) {
    let fees = await DataCache.getFees();
    let unpaidFees = fees.filter(f =>
        f.studentId === studentId &&
        !f.paid &&
        !f.hold
    ).sort((a, b) => a.month.localeCompare(b.month)); // Oldest first

    let remainingPayment = amountPaid;

    for (let fee of unpaidFees) {
        if (remainingPayment <= 0) break;

        const outstanding = fee.amount - (fee.amountPaid || 0);

        if (remainingPayment >= outstanding) {
            fee.amountPaid = fee.amount;
            fee.paid = true;
            fee.partial = false; // Ensure partial flag is cleared
            fee.paidDate = new Date().toISOString();
            fee.paymentMethod = paymentMethod;
            fee.paymentNotes = paymentNotes;
            remainingPayment -= outstanding;
        } else {
            fee.amountPaid = (fee.amountPaid || 0) + remainingPayment;
            fee.partial = true;
            fee.paidDate = new Date().toISOString();
            fee.paymentMethod = paymentMethod;
            fee.paymentNotes = paymentNotes;
            remainingPayment = 0;
        }

        await FirebaseStorage.saveFee(fee);
    }
}
// üëÜ If holding, we skip this entire block ‚Üí no payment applied ‚Üí no "partial ‚Çπ0" bug

        // Invalidate cache
        DataCache.invalidate('fees');

        // Success message
        let message = `Payment of ‚Çπ${amountPaid.toLocaleString()} recorded successfully!`;
        if (holdChecked) {
            const holdMonth = document.getElementById('holdMonthSelect').value;
            const holdYear = document.getElementById('holdYearSelect').value;
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            message += ` ‚Ä¢ ${monthNames[holdMonth]} ${holdYear} placed on hold.`;
        }
        showToast(message, 'success');

       // Refresh UI with current filters preserved
if (App.getCurrentSection() === 'all-students') {
    await AllStudents.renderAllStudents();
} else if (App.getCurrentSection() === 'fees') {
    const { searchTerm, statusFilter, monthFilter, yearFilter } = this.getCurrentFilters();
    await this.renderFeeRecords(searchTerm, statusFilter, monthFilter, yearFilter);
}
this.closePayFeeModal();

    } catch (error) {
        console.error("Failed to record payment:", error);
        showToast('Failed to save payment: ' + error.message, 'error');
    } finally {
        this.isRecording = false;
    }
}
static async downloadAllDataAsExcel() {
    showLoading('fees'); // Optional: show loader during generation
    try {
        showToast("üìä Preparing Excel file...", "success");

        // Fetch all data
        const [students, fees, batches] = await Promise.all([
            DataCache.getStudents(),
            DataCache.getFees(),
            DataCache.getBatches()
        ]);

        // Create batch ID ‚Üí Name map
        const batchMap = {};
        batches.forEach(b => {
            batchMap[b.id] = b.name || 'Unnamed Batch';
        });

        // Get date range: from earliest admission to today
        const today = new Date();
        let minYear = today.getFullYear();
        let maxYear = today.getFullYear();

        students.forEach(s => {
            if (!s.admissionDate) return;
            const admission = new Date(s.admissionDate);
            if (isNaN(admission)) return;
            const year = admission.getFullYear();
            minYear = Math.min(minYear, year);
            maxYear = Math.max(maxYear, today.getFullYear());
        });

        // Generate list of all months from minYear to maxYear
        const allMonths = [];
        for (let year = minYear; year <= maxYear; year++) {
            for (let month = 0; month <= 11; month++) { // 0=Jan, 11=Dec
                if (year === today.getFullYear() && month > today.getMonth()) break;
                allMonths.push({
                    key: `${year}-${String(month + 1).padStart(2, '0')}`,
                    label: `${['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][month]} ${year}`
                });
            }
        }

        // Build rows for Excel
        const rows = [];

        // Header row
        const headers = [
            "Student ID", "Name", "Father's Name", "Phone",
            "Course", "Batch", "Admission Date", "Monthly Fee"
        ];

        // Add month columns
        allMonths.forEach(m => {
            headers.push(`${m.label} - Status`);
            headers.push(`${m.label} - Due`);
            headers.push(`${m.label} - Paid`);
            headers.push(`${m.label} - Method`);
            headers.push(`${m.label} - Date`);
            headers.push(`${m.label} - Notes`);
        });

        rows.push(headers);

        // One row per student
        for (const student of students) {
           const row = [
    student.id?.substring(0, 8) || '',
    student.name || '',
    student.fatherName || '',
    Array.isArray(student.phone) ? student.phone.join(', ') : (student.phone || ''),
    student.course || '',
    batchMap[student.batch] || '‚Äî',
    formatDate(student.admissionDate) || '',
    student.monthlyFee || 0
];

            // For each month, find matching fee record
            for (const month of allMonths) {
                const feeRecord = fees.find(f =>
                    f.studentId === student.id &&
                    f.month === month.key
                );

                if (feeRecord) {
                    let status = 'Unpaid';
                    if (feeRecord.hold) status = 'Hold';
                    else if (feeRecord.paid) status = 'Paid';
                    else if (feeRecord.partial) status = 'Partial';

                    row.push(status);
                    row.push(feeRecord.amount || 0);
                    row.push(feeRecord.amountPaid || 0);
                    row.push(this.formatPaymentMethod(feeRecord.paymentMethod) || '');
                    row.push(feeRecord.paidDate ? formatDate(feeRecord.paidDate) : '');
                    row.push(feeRecord.paymentNotes || '');
                } else {
                    // No fee record for this month (maybe not billed yet)
                    row.push('N/A');
                    row.push(0);
                    row.push(0);
                    row.push('');
                    row.push('');
                    row.push('');
                }
            }

            rows.push(row);
        }

        // Create worksheet and workbook
        const worksheet = XLSX.utils.aoa_to_sheet(rows);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Fee Records");

        // Generate and trigger download
        XLSX.writeFile(workbook, `EduManage_All_Fee_Records_${formatDate(new Date())}.xlsx`);

        showToast("‚úÖ Excel file downloaded successfully!", "success");

    } catch (error) {
        console.error("‚ùå Failed to generate Excel:", error);
        showToast("Failed to generate Excel: " + error.message, "error");
    } finally {
        hideLoading('fees');
    }
}
     static async renderFeeRecords(searchTerm = '', statusFilter = '', monthFilter = '', yearFilter = '') {
    showLoading('fees');
    try {
        const [feesRaw, batches, students] = await Promise.all([
            DataCache.getFees(),
            DataCache.getBatches(),
            DataCache.getStudents()
        ]);

        const batchMap = {};
        batches.forEach(b => batchMap[b.id] = b.name || 'Unnamed Batch');

        let fees = feesRaw.map(f => ({
            ...f,
            batchName: batchMap[f.batch] || f.batch || '‚Äî'
        }));

        const today = new Date();

        

        // Apply filters
        if (searchTerm) {
            const term = searchTerm.toLowerCase();
            fees = fees.filter(f =>
                f.studentName.toLowerCase().includes(term) ||
                f.studentId.toLowerCase().includes(term)
            );
        }

        if (statusFilter) {
            if (statusFilter === 'paid') fees = fees.filter(f => f.paid);
            else if (statusFilter === 'unpaid') fees = fees.filter(f => !f.paid && (!f.amountPaid || f.amountPaid === 0));
            else if (statusFilter === 'partial') fees = fees.filter(f => f.partial);
        }

        if (monthFilter !== '' && monthFilter !== null) {
            const filterMonth = String(Number(monthFilter) + 1).padStart(2, '0');
            fees = fees.filter(f => f.month.endsWith(`-${filterMonth}`));
        }

        if (yearFilter) {
            fees = fees.filter(f => f.month.startsWith(yearFilter));
        }

        // Sort oldest first
        fees.sort((a, b) => parseInt(a.month.replace('-', '')) - parseInt(b.month.replace('-', '')));

        // Render table
        const tbody = document.getElementById('feesTableBody');
        if (!tbody) return;

        if (fees.length === 0) {
            tbody.innerHTML = `<tr><td colspan="9" class="no-data">No fee records found.</td></tr>`;
        } else {
           tbody.innerHTML = fees.map(fee => {
   let statusClass = 'status-unpaid', statusText = 'Unpaid';

// Check if this is a future-dated fee (billing day not reached)
if (!fee.paid && !fee.hold && !fee.partial) {
    const student = students.find(s => s.id === fee.studentId);
    if (student && student.admissionDate) {
        const admissionDate = new Date(student.admissionDate);
        const admissionDay = admissionDate.getDate();
        const [yearStr, monthStr] = fee.month.split('-');
        const feeYear = parseInt(yearStr);
        const feeMonth = parseInt(monthStr) - 1; // 0-indexed
        const billingDate = new Date(feeYear, feeMonth, admissionDay);

        if (billingDate > today) {
            statusClass = 'status-upcoming';
            statusText = 'Upcoming';
        }
    }
}
                if (fee.hold) { statusClass = 'status-hold'; statusText = 'Hold'; }
                else if (fee.paid) { statusClass = 'status-paid'; statusText = 'Paid'; }
                else if (fee.partial) { statusClass = 'status-partial'; statusText = 'Partial'; }

                return `
                    <tr ${fee.hold ? 'data-hold="true"' : ''}>
                        <td>${fee.studentId.substring(0, 6).toUpperCase()}</td>
                        <td>${fee.studentName}</td>
                        <td>${fee.batchName}</td>
                        <td>${this.formatMonthYear(fee.month)}</td>
                        <td>‚Çπ${fee.amount.toLocaleString()}</td>
                        <td>‚Çπ${(fee.amountPaid || 0).toLocaleString()}</td>
                        <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                        <td>${fee.paidDate ? formatDate(fee.paidDate) : '-'}</td>
                        <td>
                            <button class="btn btn-sm btn-primary" onclick="Fees.viewPaymentDetails(${JSON.stringify(fee).replace(/"/g, '&quot;')})">
                                <i class="fas fa-eye"></i> View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        await this.updateSummaryCards();

    } catch (error) {
        console.error("‚ùå Failed to render fee records:", error);
        showToast("Failed to load fee records.", "error");
    } finally {
        hideLoading('fees');
    }
}

            static formatMonthYear(monthKey) {
                const [year, month] = monthKey.split('-');
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            }

         static async updateSummaryCards() {
    try {
        const fees = await DataCache.getFees();
        const students = await DataCache.getStudents();
        const today = new Date();

        const totalAmount = fees.reduce((sum, f) => {
            if (f.hold) return sum;
            if (f.paid) return sum + f.amount;

            const student = students.find(s => s.id === f.studentId);
            if (!student || !student.admissionDate) return sum + f.amount;

            const admissionDate = new Date(student.admissionDate);
            if (isNaN(admissionDate)) return sum + f.amount;

            const admissionDay = admissionDate.getDate();
            const [yearStr, monthStr] = f.month.split('-');
            const year = parseInt(yearStr);
            const month = parseInt(monthStr) - 1;
            const billingDate = new Date(year, month, admissionDay);

            return today >= billingDate ? sum + f.amount : sum;
        }, 0);

        const paidAmount = fees.reduce((sum, f) => sum + (f.amountPaid || 0), 0);
        const outstanding = totalAmount - paidAmount;

        document.getElementById('totalAmount').textContent = `‚Çπ${totalAmount.toLocaleString()}`;
        document.getElementById('paidAmount').textContent = `‚Çπ${paidAmount.toLocaleString()}`;
        document.getElementById('outstandingAmount').textContent = `‚Çπ${outstanding.toLocaleString()}`;

    } catch (error) {
        console.error("Failed to update summary cards:", error);
    }
}

            static applyFilters(searchTerm = '') {
    const statusFilter = document.getElementById('feeStatusFilter')?.value || '';
    const monthFilter = document.getElementById('monthFilter')?.value || '';
    const yearFilter = document.getElementById('yearFilter')?.value || '';

    console.log("üîç Applying filters - Status:", statusFilter, "Month:", monthFilter, "Year:", yearFilter);

    this.renderFeeRecords(searchTerm, statusFilter, monthFilter, yearFilter);
}

static getCurrentFilters() {
    return {
        searchTerm: document.getElementById('feeSearch')?.value || '',
        statusFilter: document.getElementById('feeStatusFilter')?.value || '',
        monthFilter: document.getElementById('monthFilter')?.value || '',
        yearFilter: document.getElementById('yearFilter')?.value || ''
    };
}
static getCurrentFilters() {
    return {
        searchTerm: document.getElementById('feeSearch')?.value || '',
        statusFilter: document.getElementById('feeStatusFilter')?.value || '',
        monthFilter: document.getElementById('monthFilter')?.value || '',
        yearFilter: document.getElementById('yearFilter')?.value || ''
    };
}
            static viewPaymentDetails(fee) {
                const content = document.getElementById('paymentDetailsContent');
                if (!content) return;

                content.innerHTML = `
            <div style="display: grid; gap: 15px; padding: 20px; font-size: 1rem;">
                <div><strong>Student:</strong> ${fee.studentName}</div>
                <div><strong>Batch:</strong> ${fee.batch}</div>
                <div><strong>Course:</strong> ${fee.course}</div>
                <div><strong>Period:</strong> ${this.formatMonthYear(fee.month)}</div>
                <div><strong>Amount Due:</strong> ‚Çπ${fee.amount.toLocaleString()}</div>
                <div><strong>Amount Paid:</strong> ‚Çπ${(fee.amountPaid || 0).toLocaleString()}</div>
                <div><strong>Status:</strong> <span class="status-badge ${fee.paid ? 'status-paid' : fee.partial ? 'status-partial' : 'status-unpaid'}">${fee.paid ? 'Paid' : fee.partial ? 'Partial Payment' : 'Unpaid'}</span></div>
                ${fee.paidDate ? `<div><strong>Paid On:</strong> ${formatDate(fee.paidDate)}</div>` : ''}
                ${fee.paymentMethod ? `<div><strong>Method:</strong> ${this.formatPaymentMethod(fee.paymentMethod)}</div>` : ''}
                ${fee.paymentNotes ? `<div><strong>Notes:</strong> ${fee.paymentNotes}</div>` : ''}
            </div>
        `;

                document.getElementById('viewPaymentModal').style.display = 'flex';
            }

            static async recordPaymentForArchivedStudent(studentId, studentName) {
                this.openPayFeeModal();
                setTimeout(() => {
                    const select = document.getElementById('studentSelect');
                    if (!select) return;

                    let existingOption = Array.from(select.options).find(opt => opt.value === studentId);
                    if (!existingOption) {
                        const option = document.createElement('option');
                        option.value = studentId;
                        option.textContent = `${studentName} (Archived)`;
                        option.dataset.archived = "true";
                        select.appendChild(option);
                    }
                    select.value = studentId;
                    this.updateAmountDue(studentId);
                }, 50);
            }

            static formatPaymentMethod(methodKey) {
                const map = { cash: 'Cash', bank_transfer: 'Bank Transfer', upi: 'UPI', card: 'Card' };
                return map[methodKey] || methodKey;
            }
        }
        // =============================
        // üë• ALL STUDENTS MODULE (Archived + Active)
        // =============================
        class AllStudents {
            // Add at top of AllStudents class (with other static properties)
            static currentDeleteStudentId = null;
            static currentDeleteStudentName = null;

            static confirmPermanentDelete(studentId, studentName) {
                if (!studentId) {
                    showToast('Invalid student.', 'error');
                    return;
                }

                this.currentDeleteStudentId = studentId;
                this.currentDeleteStudentName = studentName;

                const modal = document.getElementById('confirmPasswordModal');
                document.getElementById('passwordForm').reset();
                modal.style.display = 'flex';
            } static async permanentDeleteStudent(studentId, studentName) {
    if (!confirm(`Are you absolutely sure you want to permanently delete "${studentName}"? This cannot be undone.`)) {
        return;
    }

    try {
        // Get all fee records for this student
        const fees = await DataCache.getFees();
        const studentFees = fees.filter(f => f.studentId === studentId);

        // üëá SHOW TOAST AFTER studentFees IS DEFINED üëá
        showToast(`‚è≥ Deleting "${studentName}" and ${studentFees.length} fee records...`, 'success');

        // Use WriteBatch to delete ALL fee records in 1 or few round trips
        if (studentFees.length > 0) {
            const BATCH_LIMIT = 500; // Firestore max per batch

            for (let i = 0; i < studentFees.length; i += BATCH_LIMIT) {
                const batch = writeBatch(db);
                const chunk = studentFees.slice(i, i + BATCH_LIMIT);

                for (const fee of chunk) {
                    batch.delete(doc(db, "fees", fee.id));
                }

                await batch.commit(); // ‚ö° Deletes entire chunk in 1 network call
                console.log(`‚úÖ Deleted ${chunk.length} fee records in batch.`);
            }
        }

        // Now delete the student
        await deleteDoc(doc(db, "students", studentId));

        // Invalidate caches
        DataCache.invalidate('students');
        DataCache.invalidate('fees');

        showToast(`‚úÖ Student "${studentName}" and ${studentFees.length} fee records deleted instantly!`, 'success');

        // Refresh UI
        await this.renderAllStudents();

    } catch (error) {
        console.error("‚ùå Failed to permanently delete student:", error);
        showToast('Failed to delete: ' + (error.message || 'Unknown error'), 'error');
    }
}
            static bindPasswordModalEvents() {
                // Close modal
                document.getElementById('closePasswordModal')?.addEventListener('click', () => {
                    document.getElementById('confirmPasswordModal').style.display = 'none';
                });

                document.getElementById('cancelPasswordBtn')?.addEventListener('click', () => {
                    document.getElementById('confirmPasswordModal').style.display = 'none';
                });

                // Handle form submission
                document.getElementById('passwordForm')?.addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const passwordInput = document.getElementById('confirmPassword');
                    const password = passwordInput.value.trim();

                    if (!password) {
                        showToast('Please enter your password.', 'error');
                        return;
                    }

                    try {
                        // Get current user
                        const user = auth.currentUser;
                        if (!user || !user.email) {
                            throw new Error('No authenticated user found.');
                        }

                        // Re-authenticate
                        const credential = EmailAuthProvider.credential(user.email, password);
                        await reauthenticateWithCredential(user, credential);

                        // Password correct ‚Üí proceed to delete
                        await this.permanentDeleteStudent(this.currentDeleteStudentId, this.currentDeleteStudentName);

                        // Close modal
                        document.getElementById('confirmPasswordModal').style.display = 'none';

                    } catch (error) {
                        console.error("Password verification failed:", error);
                        if (error.code === 'auth/wrong-password') {
                            showToast('Incorrect password. Please try again.', 'error');
                        } else if (error.code === 'auth/too-many-requests') {
                            showToast('Too many attempts. Try again later.', 'error');
                        } else {
                            showToast('Authentication failed: ' + error.message, 'error');
                        }
                    }
                });
            }
            static async init() {
                await this.renderAllStudents();
                this.bindEvents();
                this.bindPasswordModalEvents(); // ‚Üê ADD THIS LINE
            }

            static bindEvents() {
                document.getElementById('searchAllStudents')?.addEventListener('input', (e) => {
                    this.filterStudents(e.target.value);
                });
            }
            static async renderAllStudents(filterText = '') {
                showLoading('all-students');
                try {
                    const [studentsRaw, fees, batches] = await Promise.all([
                        DataCache.getStudents(),
                        DataCache.getFees(),
                        DataCache.getBatches()
                    ]);

                    // Create batch ID ‚Üí Name map
                    const batchMap = {};
                    batches.forEach(b => {
                        batchMap[b.id] = b.name || 'Unnamed Batch';
                    });

                    // Attach financials + resolve batch name
                    let students = studentsRaw.map(s => {
                    const studentFees = fees.filter(f => f.studentId === s.id && !f.hold); // üëà Exclude held
const totalDue = studentFees.reduce((sum, f) => sum + (f.amount || 0), 0);
const totalPaid = studentFees.reduce((sum, f) => sum + (f.amountPaid || 0), 0);
                        return {
                            ...s,
                            totalDue,
                            totalPaid,
                            outstanding: totalDue - totalPaid,
                            batchName: batchMap[s.batch] || (s.batch ? 'Unknown Batch' : '‚Äî')
                        };
                    });

                    if (filterText) {
                        const term = filterText.toLowerCase();
                        students = students.filter(s =>
                            (s.name?.toLowerCase().includes(term)) ||
                            (s.fatherName?.toLowerCase().includes(term))
                        );
                    }

                    const tbody = document.getElementById('allStudentsTableBody');
                    if (!tbody) return;

                    if (students.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="11">No students found.</td></tr>';
                        return;
                    }

                    tbody.innerHTML = students.map(s => `
<tr class="${s.deleted ? 'table-danger' : ''}">
    <td>${s.id?.substring(0, 6).toUpperCase() || '‚Äî'}</td>
    <td>${s.name || '‚Äî'}</td>
    <td>${s.fatherName || '‚Äî'}</td>
    <td>
    ${s.phone && Array.isArray(s.phone) 
        ? s.phone.join('<br>') 
        : s.phone || '‚Äî'
    }
</td>
    <td>${s.course || '‚Äî'}</td>
    <td>${s.batchName}</td> <!-- üëà NOW SHOWS BATCH NAME -->
    <td>${formatDate(s.admissionDate) || '‚Äî'}</td>
    <td>‚Çπ${s.totalDue.toLocaleString()}</td>
    <td>‚Çπ${s.totalPaid.toLocaleString()}</td>
    <td>‚Çπ${s.outstanding.toLocaleString()}</td>
    <td>
        <span class="badge ${s.deleted ? 'bg-danger' : 'bg-success'}">
            ${s.deleted ? 'Archived' : 'Active'}
        </span>
        ${s.deleted ? `
            <button class="btn btn-xs btn-outline-primary ms-2" onclick="Fees.recordPaymentForArchivedStudent('${s.id}', '${(s.name || '').replace(/'/g, "\\'").replace(/"/g, "&quot;")}')">
                <i class="fas fa-money-bill"></i> Record Payment
            </button>
        ` : ''}
        <button class="btn btn-xs btn-outline-danger ms-2" onclick="AllStudents.confirmPermanentDelete('${s.id}', '${(s.name || '').replace(/'/g, "\\'").replace(/"/g, "&quot;")}')">
            <i class="fas fa-trash-alt"></i> Delete
        </button>
    </td>
</tr>
`).join('');

                } catch (error) {
                    console.error("‚ùå Failed to load all students:", error);
                    showToast('Failed to load all students.', 'error');
                } finally {
                    hideLoading('all-students'); // Hide loading
                }
            }

            static filterStudents(query) {
                this.renderAllStudents(query);
            }
        }

        // Expose modules globally for HTML onclick handlers
        window.App = App;
        window.Auth = Auth;
        window.Dashboard = Dashboard;
        window.Students = Students;
        window.Batches = Batches;
        window.Fees = Fees;
        window.AllStudents = AllStudents;

        // Start App on DOM Ready
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });

        console.log("‚úÖ EduManage Single-File SPA Loaded Successfully.");
    </script>
</body>

</html>